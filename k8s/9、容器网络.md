<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [容器中的网络](#%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C)
  - [容器网络](#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 容器中的网络

### 容器网络

docker 容器是一种特殊的进程，docker 容器在创建进程时，指定了这个进程所需要启用的一组 Namespace 参数。这样，容器就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。   

容器可以直接使用宿主机的网络栈（–net=host），即：不开启 `Network Namespace`，比如：  

```
$ docker run –d –net=host --name nginx-host nginx
```

在这种情况下，这个容器启动后，直接监听的就是宿主机的 80 端口。  

通常情况下，容器一般会选择使用自己 `Network Namespace` 里的网络栈，即：拥有属于自己的 IP 地址和端口。这种情况下，被隔离的容器进程是如何和其他的容器进程进行通信呢？    

Docker 项目会默认在宿主机上创建一个名叫 docker0 的网桥，凡是连接在 docker0 网桥上的容器，就可以通过它来进行通信。容器中通过 `Veth Pair` 来连接到 docker0 网桥上。   

什么是 `Veth Pair` 呢？  

`veth pair` 是成对出现的一种虚拟网络设备接口，一端连着网络协议栈，一端彼此相连。  

`Veth Pair` 的特点总是以两张虚拟网卡（Veth Peer）的形式成对出现的。从其中一个"网卡"发出的数据包，可以直接出现在与它对应的另一张"网卡"上，这两张网卡可以在不同的 `Network Namespace` 里。所以 `Veth Pair` 可以用来进行跨 `Network Namespace` 网络互联。   

这里来简单分析下原理  


















### 参考

【深入剖析 Kubernetes】https://time.geekbang.org/column/intro/100015201?code=UhApqgxa4VLIA591OKMTemuH1%2FWyLNNiHZ2CRYYdZzY%3D  





