<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [k8s 总体概览](#k8s-%E6%80%BB%E4%BD%93%E6%A6%82%E8%A7%88)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [Pod](#pod)
  - [副本控制器（Replication Controller，RC）](#%E5%89%AF%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%99%A8replication-controllerrc)
  - [副本集（Replica Set，RS）](#%E5%89%AF%E6%9C%AC%E9%9B%86replica-setrs)
  - [部署（Deployment）](#%E9%83%A8%E7%BD%B2deployment)
  - [服务（Service）](#%E6%9C%8D%E5%8A%A1service)
  - [ingress](#ingress)
  - [节点（Node）](#%E8%8A%82%E7%82%B9node)
  - [命名空间（Namespace）](#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4namespace)
  - [k8s 中的部署过程](#k8s-%E4%B8%AD%E7%9A%84%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B)
    - [1、创建命名空间](#1%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4)
    - [2、使用 deployment 部署 pod](#2%E4%BD%BF%E7%94%A8-deployment-%E9%83%A8%E7%BD%B2-pod)
    - [3、为服务创建 service](#3%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA-service)
    - [4、配置 ingress 的转发策略](#4%E9%85%8D%E7%BD%AE-ingress-%E7%9A%84%E8%BD%AC%E5%8F%91%E7%AD%96%E7%95%A5)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## k8s 总体概览

### 前言

学习 k8s 之前首先对 k8s 中具体的组件做个简单的了解。   

### Pod

Pod 是 k8s 中集群部署应用和服务的最小单元，一个 pod 中可以部署多个容器。  

Pod 的设计理念是支持多个容器在一个 Pod 中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod 对多容器的支持是 K8 最基础的设计理念。  

### 副本控制器（Replication Controller，RC）

RC 是 k8s 集群中最早的保证 Pod 高可用的 API 对象。它的作用就是保证集群中有指定数目的 pod 运行。     

当前运行的 pod 数目少于指定的数目，RC 就会启动新的 pod 副本，保证运行 pod 数量等于指定数目。  

当前运行的 pod 数目大于指定的数目，RC 就会杀死多余的 pod 副本。   

### 副本集（Replica Set，RS）

RS 是新一代 RC，提供同样的高可用能力，区别主要在于 RS 后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为 Deployment 的理想状态参数使用。  

### 部署（Deployment）

Deployment 提供了一种对 Pod 和 ReplicaSet 的管理方式，每一个 Deployment 都对应集群中的一次部署，是非常常见的 Kubernetes 对象。   

Deployment 是一个比 RS 应用模式更广的 API 对象，可以用来创建一个新的服务，更新一个新的服务，也可以用来滚动升级一个服务。   

滚动升级一个服务，滚动升级一个服务，实际是创建一个新的 RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧 RS 中的副本数减小到 0 的复合操作；这样一个复合操作用一个 RS 是不太好描述的，所以用一个更通用的 Deployment 来描述。   

### 服务（Service）  

RC、RS 和 Deployment 只是保证了支撑服务的微服务 Pod 的数量。但是没有解决如何访问这些服务的问题。  

一个 Pod 只是一个运行服务的实例，随时可能在节点上停止，然后再新的节点上用一个新的 IP 启动一个新的 Pod,因此不能使用确定的 IP 和端口号提供服务。这对于业务来说，就不能根据 Pod 的 IP 作为业务调度。kubernetes 就引入了 Service 的概 念，它为 Pod 提供一个入口，主要通过 Labels 标签来选择后端Pod，这时候不论后端 Pod 的 IP 地址如何变更，只要 Pod 的 Labels 标签没变，那么 业务通过 service 调度就不会存在问题。   

当声明Service的时候，会自动生成一个cluster IP，这个IP是虚拟IP。我们就可以通过这个IP来访问后端的Pod，当然，如果集群配置了DNS服务，比如现在 的CoreDNS，那么也可以通过Service的名字来访问，它会通过DNS自动解析Service的IP地址。  

### ingress 

Ingress 是反向代理规则，用来规定 HTTP/S 请求应该被转发到哪个 Service 上，比如根据请求中不同的 Host 和 url 路径让请求落到不同的 Service 上。   

Ingress Controller 就是一个反向代理程序，它负责解析 Ingress 的反向代理规则，如果 Ingress 有增删改的变动，所有的 Ingress Controller 都会及时更新自己相应的转发规则，当 Ingress Controller 收到请求后就会根据这些规则将请求转发到对应的 Service。   

Kubernetes 并没有自带 Ingress Controller，它只是一种标准，具体实现有多种，需要自己单独安装，常用的是 Nginx Ingress Controller 和 Traefik Ingress Controller。  

一个集群中可以有多个 Ingress Controller， 在Ingress 中可以指定使用哪一个Ingress Controller。  

<img src="/img/k8s/k8s-ingress.jpg"  alt="k8s" /> 

### 节点（Node）

k8s 中通过将容器放入到节点 Node 上运行的 Pod 中来执行工作负载。 k8s 中的计算能力就是由 node 提供。  

节点可以是物理机也可以是虚拟机，取决于集群的配置，通常 k8s 集群中，有越多的 node 节点，意味着有更强的计算能力。   

### 命名空间（Namespace）

命名空间为 Kubernetes 集群提供虚拟的隔离作用，Kubernetes 集群初始有两个命名空间，分别是默认命名空间 default 和系统命名空间 kube-system，除此以外，管理员可以可以创建新的命名空间满足需要。  

名字空间适用于存在很多跨多个团队或项目的用户的场景。对于只有几到几十个用户的集群，根本不需要创建或考虑名字空间。   

### k8s 中的部署过程   

这里用一个简单的栗子来看下，看下 k8s 中应用的部署过程。   

#### 1、创建命名空间   

```
$ kubectl create namespace study-k8s
```

#### 2、使用 deployment 部署 pod  

```
$ cat go-web.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: go-web
  name: go-web
  namespace: study-k8s
spec:
  replicas: 5
  selector:
    matchLabels:
      app: go-web
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: go-web
    spec:
      containers:
      - image: liz2019/test-docker-go-hub
        name: go-app-container
        resources: {}
status: {}
```

运行 

```
$ kubectl apply -f go-web.yaml  -n study-k8s

$ kubectl get pods  -n study-k8s
NAME                      READY   STATUS    RESTARTS   AGE
go-web-59f7dc559c-g2hjg   1/1     Running   0          5h21m
go-web-59f7dc559c-g6p8k   1/1     Running   0          5h21m
go-web-59f7dc559c-l4fgm   1/1     Running   0          5h21m
go-web-59f7dc559c-lqvpj   1/1     Running   0          5h21m
go-web-59f7dc559c-rrdjp   1/1     Running   0          5h21m

$ kubectl describe deployment nginx-deploy  -n  study-k8s
Name:                   go-web
Namespace:              study-k8s
CreationTimestamp:      Wed, 07 Sep 2022 15:33:58 +0800
Labels:                 app=go-web
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               app=go-web
Replicas:               5 desired | 5 updated | 5 total | 5 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=go-web
  Containers:
   go-app-container:
    Image:        liz2019/test-docker-go-hub
    Port:         <none>
    Host Port:    <none>
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  <none>
NewReplicaSet:   go-web-59f7dc559c (5/5 replicas created)
Events:          <none>
```

Deployment 为 Pod 和 `Replica Set` 提供声明式更新。所以可以看到创建的 Deployment 里面就同时也创建好了 `Replica Set`。   

#### 3、为服务创建 service   

上面我们创建了一组 Pod ，接下来，我们借助于 service 来实现对这些 Pod 的访问。   

```
$ cat go-web-svc.yaml 
apiVersion: v1
kind: Service
metadata:
  name: go-web-svc
  labels:
    run: go-web-svc
spec:
  type: NodePort
  selector:
    app: go-web
  ports:
    - protocol: TCP
      port: 8000
      targetPort: 8000
```

运行   

```
$ kubectl apply -f go-web-svc.yaml -n study-k8s

$  kubectl get svc -n study-k8s
NAME         TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
go-web-svc   NodePort   10.233.57.240   <none>        8000:30614/TCP   19m

$ kubectl describe svc go-web-svc  -n  study-k8s
Name:                     go-web-svc
Namespace:                study-k8s
Labels:                   run=go-web-svc
Annotations:              <none>
Selector:                 app=go-web
Type:                     NodePort
IP:                       10.233.57.240
Port:                     <unset>  8000/TCP
TargetPort:               8000/TCP
NodePort:                 <unset>  30614/TCP
Endpoints:                10.233.111.104:8000,10.233.111.105:8000,10.233.111.106:8000 + 2 more...
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   <none>
```

可以看到 service 已经创建完成。

使用的是 NodePort，使用 `node ip` + `svc port` 即可访问  

#### 4、配置 ingress 的转发策略

service 已经创建成功了，接下来我们使用 ingress     

```
$ cat go-web-ingress.yaml    
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: go-web-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
spec:
  rules:
  - host: www.go-web.com
    http:
      paths:
      - path: /index
        pathType: Prefix
        backend:
          service:
            name: go-web-svc
            port:
              number: 8000
```

部署 ingress  

```
$ kubectl apply -f go-web-ingress.yaml -n study-k8s

$ kubectl get ingress -n study-k8s
NAME             CLASS    HOSTS            ADDRESS         PORTS   AGE
go-web-ingress   <none>   www.go-web.com   11.11.111.113   80      107s
```

### 参考

【Kubernetes 的设计理念】https://jimmysong.io/kubernetes-handbook/concepts/concepts.html    
【Kubernetes中文文档】http://docs.kubernetes.org.cn/  

