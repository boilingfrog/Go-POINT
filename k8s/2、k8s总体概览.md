<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [k8s 总体概览](#k8s-%E6%80%BB%E4%BD%93%E6%A6%82%E8%A7%88)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [Pod](#pod)
  - [副本控制器（Replication Controller，RC）](#%E5%89%AF%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%99%A8replication-controllerrc)
  - [副本集（Replica Set，RS）](#%E5%89%AF%E6%9C%AC%E9%9B%86replica-setrs)
  - [部署（Deployment）](#%E9%83%A8%E7%BD%B2deployment)
  - [服务（Service）](#%E6%9C%8D%E5%8A%A1service)
  - [ingress](#ingress)
  - [节点（Node）](#%E8%8A%82%E7%82%B9node)
  - [命名空间（Namespace）](#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4namespace)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## k8s 总体概览

### 前言

学习 k8s 之前首先对 k8s 中具体的组件做个简单的了解。   

### Pod

Pod 是 k8s 中集群部署应用和服务的最小单元，一个 pod 中可以部署多个容器。  

Pod 的设计理念是支持多个容器在一个 Pod 中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod 对多容器的支持是 K8 最基础的设计理念。  

### 副本控制器（Replication Controller，RC）

RC 是 k8s 集群中最早的保证 Pod 高可用的 API 对象。它的作用就是保证集群中有指定数目的 pod 运行。     

当前运行的 pod 数目少于指定的数目，RC 就会启动新的 pod 副本，保证运行 pod 数量等于指定数目。  

当前运行的 pod 数目大于指定的数目，RC 就会杀死多余的 pod 副本。   

### 副本集（Replica Set，RS）

RS 是新一代 RC，提供同样的高可用能力，区别主要在于 RS 后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为 Deployment 的理想状态参数使用。  

### 部署（Deployment）

Deployment 提供了一种对 Pod 和 ReplicaSet 的管理方式，每一个 Deployment 都对应集群中的一次部署，是非常常见的 Kubernetes 对象。   

Deployment 是一个比 RS 应用模式更广的 API 对象，可以用来创建一个新的服务，更新一个新的服务，也可以用来滚动升级一个服务。   

滚动升级一个服务，滚动升级一个服务，实际是创建一个新的 RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧 RS 中的副本数减小到 0 的复合操作；这样一个复合操作用一个 RS 是不太好描述的，所以用一个更通用的 Deployment 来描述。   

### 服务（Service）  

RC、RS 和 Deployment 只是保证了支撑服务的微服务 Pod 的数量。但是没有解决如何访问这些服务的问题。  

一个 Pod 只是一个运行服务的实例，随时可能在节点上停止，然后再新的节点上用一个新的 IP 启动一个新的 Pod,因此不能使用确定的 IP 和端口号提供服务。这对于业务来说，就不能根据 Pod 的 IP 作为业务调度。kubernetes 就引入了 Service 的概 念，它为 Pod 提供一个入口，主要通过 Labels 标签来选择后端Pod，这时候不论后端 Pod 的 IP 地址如何变更，只要 Pod 的 Labels 标签没变，那么 业务通过 service 调度就不会存在问题。   

当声明Service的时候，会自动生成一个cluster IP，这个IP是虚拟IP。我们就可以通过这个IP来访问后端的Pod，当然，如果集群配置了DNS服务，比如现在 的CoreDNS，那么也可以通过Service的名字来访问，它会通过DNS自动解析Service的IP地址。  

### ingress 

Ingress 是反向代理规则，用来规定 HTTP/S 请求应该被转发到哪个 Service 上，比如根据请求中不同的 Host 和 url 路径让请求落到不同的 Service 上。   

Ingress Controller 就是一个反向代理程序，它负责解析 Ingress 的反向代理规则，如果 Ingress 有增删改的变动，所有的 Ingress Controller 都会及时更新自己相应的转发规则，当 Ingress Controller 收到请求后就会根据这些规则将请求转发到对应的 Service。   

Kubernetes 并没有自带 Ingress Controller，它只是一种标准，具体实现有多种，需要自己单独安装，常用的是 Nginx Ingress Controller 和 Traefik Ingress Controller。  

一个集群中可以有多个 Ingress Controller， 在Ingress 中可以指定使用哪一个Ingress Controller。  

<img src="/img/k8s/k8s-ingress.jpg"  alt="k8s" /> 

### 节点（Node）

k8s 中通过将容器放入到节点 Node 上运行的 Pod 中来执行工作负载。 k8s 中的计算能力就是由 node 提供。  

节点可以是物理机也可以是虚拟机，取决于集群的配置，通常 k8s 集群中，有越多的 node 节点，意味着有更强的计算能力。   

### 命名空间（Namespace）

命名空间为 Kubernetes 集群提供虚拟的隔离作用，Kubernetes 集群初始有两个命名空间，分别是默认命名空间 default 和系统命名空间 kube-system，除此以外，管理员可以可以创建新的命名空间满足需要。  

名字空间适用于存在很多跨多个团队或项目的用户的场景。对于只有几到几十个用户的集群，根本不需要创建或考虑名字空间。   

### k8s 中的部署过程   

这里用一个简单的栗子来看下，看下 k8s 中应用的部署过程。   

1、创建命名空间   

```
$ kubectl create namespace study-k8s
```

2、使用 deployment 部署 pod  

```
$ kubectl create deployment nginx-deploy --image=nginx:1.23 --namespace=study-k8s --replicas=5 --dry-run -o yaml > nginx.yml  

$ cat nginx.yml 
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: nginx-deploy
  name: nginx-deploy
  namespace: study-k8s
spec:
  replicas: 5
  selector:
    matchLabels:
      app: nginx-deploy
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: nginx-deploy
    spec:
      containers:
      - image: nginx:1.23
        name: nginx
        resources: {}
status: {}
```

运行 

```
$ kubectl apply -f nginx.yml -n study-k8s

$ kubectl get pods  -n study-k8s
NAME                         READY   STATUS    RESTARTS   AGE
nginx-deploy-7cc4c6698b-2cjwl   1/1     Running   0          3m32s
nginx-deploy-7cc4c6698b-9bjkq   1/1     Running   0          3m32s
nginx-deploy-7cc4c6698b-9mdnz   1/1     Running   0          3m32s
nginx-deploy-7cc4c6698b-j9prk   1/1     Running   0          3m32s
nginx-deploy-7cc4c6698b-jqq5h   1/1     Running   0          3m32s

$ kubectl describe deployment nginx-deploy  -n  study-k8s
Name:                   nginx-deploy
Namespace:              study-k8s
CreationTimestamp:      Sun, 04 Sep 2022 20:57:39 +0800
Labels:                 app=nginx-deploy
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               app=nginx-deploy
Replicas:               5 desired | 5 updated | 5 total | 5 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx-deploy
  Containers:
   nginx:
    Image:        nginx:1.23
    Port:         <none>
    Host Port:    <none>
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  <none>
NewReplicaSet:   nginx-deploy-7cc4c6698b (5/5 replicas created)
Events:
  Type    Reason             Age    From                   Message
  ----    ------             ----   ----                   -------
  Normal  ScalingReplicaSet  4m24s  deployment-controller  Scaled up replica set nginx-deploy-7cc4c6698b to 5
```

Deployment 为 Pod 和 `Replica Set` 提供声明式更新。所以可以看到创建的 Deployment 里面就同时也创建好了 `Replica Set`。   

3、为服务创建 service   

上面我们创建了一组 Pod ，接下来，我们借助于 service 来实现对这些 Pod 的访问。   

```
$ cat nginx-svc.yml 
apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
spec:
  selector:
    app: nginx-deploy
  ports:
    - protocol: TCP
      port: 80
      targetPort: 6000
```

运行   

```
$ kubectl apply -f nginx-svc.yml -n study-k8s

$  kubectl get svc -n study-k8s
NAME        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
nginx-svc   ClusterIP   xx.xx.xxx.xx   <none>        80/TCP    13s

$ kubectl describe svc nginx-svc  -n  study-k8s
Name:              nginx-svc
Namespace:         study-k8s
Labels:            <none>
Annotations:       <none>
Selector:          app=nginx-deploy
Type:              ClusterIP
IP:                10.233.19.237
Port:              <unset>  80/TCP
TargetPort:        6000/TCP
Endpoints:         10.233.111.81:6000,10.233.111.82:6000,10.233.67.69:6000 + 2 more...
Session Affinity:  None
Events:            <none>
```

可以看到 service 已经创建完成。  

4、配置 ingress 的转发策略

service 已经创建成功了，接下来我们使用 ingress     

```
$ cat nginx-ingress.yaml 

apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: nginx-ingress
spec:
  rules:
  - host: www.liz-test.com
    http:
      paths:
      - backend:
          serviceName: nginx-svc
          servicePort: 6000
```

### 参考

【Kubernetes 的设计理念】https://jimmysong.io/kubernetes-handbook/concepts/concepts.html    
【Kubernetes中文文档】http://docs.kubernetes.org.cn/  

