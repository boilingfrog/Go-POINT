<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [k8s 中的网络模型](#k8s-%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B)
  - [CNI 网络插件](#cni-%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6)
    - [CNI 的设计思想](#cni-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3)
  - [k8s 中的三层网络](#k8s-%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E7%BD%91%E7%BB%9C)
    - [Flannel 的 host-gw](#flannel-%E7%9A%84-host-gw)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## k8s 中的网络模型

### CNI 网络插件  

docker 容器的网络都是连接在 docker0 网桥上的，容器中所有的流量都由  docker0 网桥转发出去。  

例如 Flannel 中 UDP 模式通过 TUN 设备，VXLAN 模式通过 VTEP 设备，来接入容器中的网络，这些设备都是连接在 docker0 网桥上面和容器中的网络进行交互的。  

网络插件的作用就是把这些宿主机中的网络设备连通，从而达到网络跨主机通信的目的。      

Kubernetes 中处理网络的方式和容器中的类似，不是的是 Kubernetes 中使用 CNI 网桥，替代了 docker0 网桥。    

例如 Flannel 的 VXLAN 模式，在 Kubernetes 中和  docker 容器中的工作方式基本相同，只是 docker0 网桥被替换成了 CNI 网桥。  

<img src="/img/k8s/k8s-flannel-vxlan-cni.png"  alt="k8s" />       

#### CNI 的设计思想

CNI 的设计思想：Kubernetes 在启动 Infra 容器之后，就可以直接调用 CNI 网络插件，为这个 Infra 容器的 `Network Namespace`，配置符合预期的网络栈。    

CNI 的基础可执行文件有下面三类：  

1、Main 插件，用来创建具体网络设备的二进制文件，栗如 bridge（网桥设备）、ipvlan、loopback（lo 设备）等；

2、IPAM 插件，负责分配 IP 地址的二进制文件，栗如 dhcp，这个文件会向 DHCP 服务器发起请求；host-local，则会使用预先配置的 IP 地址段来进行分配；   

3、是由 CNI 社区维护的内置 CNI 插件。   

要实现一个 Kubernetes 中的网络有下面两个步骤   

1、实现网络方案本身。栗如：对于 Flannel ，就是要实现 flanneld 进程里的主要逻辑。创建和配置 flannel.1 设备、配置宿主机路由、配置 ARP 和 FDB 表里的信息等等；   

2、实现该网络方案对应的 CNI 插件。要做的就是配置 Infra 容器里面的网络栈，并把它连接在 CNI 网桥上。    

### k8s 中的三层网络  

这里通过 Flannel 的 host-gw 模式和 Calico 项目来了解下 k8s 中的三层网络。   

#### Flannel 的 host-gw

host-gw 即 Host Gateway，这个模式就是将每个 Flannel 子网的下一跳，设置成了该子网对应的宿主机的 IP 地址。这样宿主机就充当了容器通信路径的"网关"作用。   

Flannel 子网和主机的信息，都被保存在 etcd 中，flanneld 只需要 WACTH 这些数据的变化，然后实时更新路由表即可。    

注意：在 `Kubernetes v1.7` 之后，类似 `Flannel、Calico` 的 CNI 网络插件都是可以直接连接 Kubernetes 的 APIServer 来访问 Etcd 的，无需额外部署 Etcd 给它们使用。   

<img src="/img/k8s/k8s-flannel-hostgw.png"  alt="k8s" />       

host-gw 模式，容器的通行过程，没有了额外的解包和封包的带来的性能损耗，对比 VXLAN 模式有更高的性能。   

host-gw 模式能够工作的核心就是在于 IP 包被封装成帧发出去的时候，会使用路由表中的"下一跳"来设置目的 MAC 地址，这样就能通过二层网络到达目的宿主机。   









### 参考

【深入剖析 Kubernetes】https://time.geekbang.org/column/intro/100015201?code=UhApqgxa4VLIA591OKMTemuH1%2FWyLNNiHZ2CRYYdZzY%3D     
 