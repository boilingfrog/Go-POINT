- [pgsql中的事务隔离级别](#pgsql%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [事物隔离级别](#%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)
    - [在各个级别上被禁止出现的现象是](#%E5%9C%A8%E5%90%84%E4%B8%AA%E7%BA%A7%E5%88%AB%E4%B8%8A%E8%A2%AB%E7%A6%81%E6%AD%A2%E5%87%BA%E7%8E%B0%E7%9A%84%E7%8E%B0%E8%B1%A1%E6%98%AF)
      - [脏读](#%E8%84%8F%E8%AF%BB)
      - [不可重复读](#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB)
      - [幻读](#%E5%B9%BB%E8%AF%BB)
      - [序列化异常](#%E5%BA%8F%E5%88%97%E5%8C%96%E5%BC%82%E5%B8%B8)
  - [读已提交隔离级别](#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)
  - [可重复读隔离级别](#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)
  - [可序列化隔离级别](#%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)
  - [摘录](#%E6%91%98%E5%BD%95)


## pgsql中的事务隔离级别

### 前言

最近在学习pgsql里面的锁，但是忽然发现对于事物的隔离有点模糊，不能很好的进行知识的串联。那么就来认真总结下吧。


### 事物隔离级别

这是官方文档的描述
>SQL标准定义了四种隔离级别。最严格的是可序列化，在标准中用了一整段来定义它，其中说到一组可序列化事务的任意并发执行被保证效果和以某种顺序一个一个执行这些事务一样。其他三种级别使用并发事务之间交互产生的现象来定义，每一个级别中都要求必须不出现一种现象。注意由于可序列化的定义，在该级别上这些现象都不可能发生（这并不令人惊讶--如果事务的效果与每个时刻只运行一个的相同，你怎么可能看见由于交互产生的现象？）。

四种事务隔离级别分别是：  
读未提交  
读已提交  
可重复读  
可序列化  

#### 在各个级别上被禁止出现的现象是

##### 脏读

一个事物读取了另一个并行未提交事物写入的数据。

##### 不可重复读

一个事物重新读取之前的数据，发现这个数据已经被另一个事物（在初读之后提交）修改。

##### 幻读

一个事物重新执行了一个返回符合条件的行集合的查询，发现满足条件的行集合因为另一个最近提交的事物发生了改变。

##### 序列化异常

成功提交一组事物的结果与这些事物所有可能串行执行结果不一致。

![](https://img2020.cnblogs.com/blog/1237626/202004/1237626-20200408173711728-1923933673.png)

在PostgreSQL中，你可以请求四种标准事务隔离级别中的任意一种，但是内部只实现了三种不同的隔离级别，即 PostgreSQL 的读未提交模式的行为和读已提交相同。这是因为把标准隔离级别映射到 PostgreSQL 的多版本并发控制架构的唯一合理的方法。

### 读已提交隔离级别

****读已提交是pgsql中默认的隔离级别****。当一个事务使用这个隔离级别时，一个查询（没有FOR UPDATE/SHARE子句）只能看到查询开始之前已经
被提交的数据，而无法看到未提交的数据或在查询执行期间其他事物提交的数据。

****在不同的事务之间****：SELECT查询看到的是一个在查询开始运行的瞬间该数据库的一个快照，当一个事务a对数据进行了修改，a事务还没有提交的时候另一个事务b查询到的数据就是，事务a未修改之前的数据，也就是查询开始之前的瞬间，数据库的一个快照。  
****在同一个事务之间****：SELECT可以看见在它自身事务中之前执行的更新的效果，即使它们还没有被提交。也就是更新完成之后的数据，是马上可以被查询到的，这就造成了，在同一个事务之间先后查询的结果可能不一样，当更新操作在两个查询之间进行，后面的查询就是更新后的数据了。  

UPDATE、DELETE、SELECT FOR UPDATE和SELECT FOR SHARE命令在搜索目标行时的行为和SELECT一样： 它们将只找到在命令开始时已经被提交的行。 不过，在被找到时，这样的目标行可能已经被其它并发事务更新（或删除或锁住）。在这种情况下， 即将进行的更新将等待第一个更新事务提交或者回滚（如果它还在进行中）。 如果第一个更新事务回滚，那么它的作用将被忽略并且第二个事务可以继续更新最初发现的行。 如果第一个更新事务提交，若该行被第一个更新者删除，则第二个更新事务将忽略该行，否则第二个更新者将试图在该行的已被更新的版本上应用它的操作。该命令的搜索条件（WHERE子句）将被重新计算来看该行被更新的版本是否仍然符合搜索条件。如果符合，则第二个更新者使用该行的已更新版本继续其操作。在SELECT FOR UPDATE和SELECT FOR SHARE的情况下，这意味着把该行的已更新版本锁住并返回给客户端。

### 可重复读隔离级别

可重复读隔离级别只能看到事物之前提交的数据；它从来看不到未提交的数据或者并行
事物在本事务执行期间提交的修改。（不过，查询能够看见在它的事务中之前执行的更新，即使它们还没有被提交）。

这个级别与读已提交不同之处在于，一个可重复读事务中的查询可以看见在事务中第一个非事务控制语句开始时的一个快照，而不是事务中当前语句开始时的快照。因此，在一个单一事务中的后续SELECT命令看到的是相同的数据，即它们看不到其他事务在本事务启动后提交的修改。

UPDATE、DELETE、SELECT FOR UPDATE和SELECT FOR SHARE命令在搜索目标行时的行为和SELECT一样： 它们将只找到在事务开始时已经被提交的行。 不过，在被找到时，这样的目标行可能已经被其它并发事务更新（或删除或锁住）。在这种情况下， 可重复读事务将等待第一个更新事务提交或者回滚（如果它还在进行中）。 如果第一个更新事务回滚，那么它的作用将被忽略并且可重复读事务可以继续更新最初发现的行。 但是如果第一个更新事务提交（并且实际更新或删除该行，而不是只锁住它），则可重复读事务将回滚并带有如下消息

````
ERROR:  could not serialize access due to concurrent update
````

因为一个可重复读事务无法修改或者锁住被其他在可重复读事务开始之后的事务改变的行。

### 可序列化隔离级别

可序列化隔离级别提供了最严格的事务隔离。这个级别为所有已提交事务模拟序列事务执行；就好像事务被按照序列一个接着另一个被执行，而不是并行地被执行。但是，和可重复读级别相似，使用这个级别的应用必须准备好因为序列化失败而重试事务。事实上，这个隔离级别完全像可重复读一样地工作，除了它会监视一些条件，这些条件可能导致一个可序列化事务的并发集合的执行产生的行为与这些事务所有可能的序列化（一次一个）执行不一致。这种监控不会引入超出可重复读之外的阻塞，但是监控会产生一些负荷，并且对那些可能导致序列化异常的条件的检测将触发一次序列化失败。


### 摘录
【PostgreSQL 11.2 手册】http://postgres.cn/docs/11