<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [运输层](#%E8%BF%90%E8%BE%93%E5%B1%82)
  - [为什么需要运输层](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%90%E8%BE%93%E5%B1%82)
  - [TCP 和 UDP](#tcp-%E5%92%8C-udp)
    - [UDP](#udp)
    - [TCP](#tcp)
      - [TCP 的连接](#tcp-%E7%9A%84%E8%BF%9E%E6%8E%A5)
  - [可靠性传输原理](#%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86)
    - [停止等待协议](#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE)
    - [信道利用率](#%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87)
      - [连续 ARQ 协议](#%E8%BF%9E%E7%BB%AD-arq-%E5%8D%8F%E8%AE%AE)
  - [TCP 报文段的首部格式](#tcp-%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 运输层

### 为什么需要运输层

运输层（传输层），解决的是计算机程序到计算机程序之间的通信问题，即所谓的“端”到 “端”的通信。    

⽹络层最终解决的问题：

分组从⼀台主机经过⽹络到达另⼀台主机，即主机到主机间的通信。

⽹络层没有解决的问题： 

1、主机中谁发送的数据、谁接收数据；  

2、IP分组⽆序到达⽬的主机，接收进程如何处理；  

3、可靠传输问题。  

引入传输层的原因： 

1、增加复用和分用的功能；  

2、消除网络层的不可靠性；  

3、提供从源端主机到目的端主机的可靠的、与实际使用的网络无关的信息传输。      

<img src="/img/ip/ip-transport-effect.jpg"  alt="tcp" />

进程之间的通信  

从 IP 的角度，通信的两端是两台主机。但“两台主机之间的通信”这种说法还不够清楚；严格地讲，两台主机进⾏通信就是两台主机中的应⽤进程互相通信；  

从运输层的⻆度看，通信的真正端点并不是主机⽽是主机中的进程。也就是说，端到端的通信是应⽤进程之间的通信。  

网络层和运输层的区别  

<img src="/img/ip/ip-transport-different-with-network.jpg"  alt="tcp" />  

### TCP 和 UDP 

根据应⽤程序的不同需求，运输层需要有两种不同的运输协议：

1、即⾯向连接的 TCP；

2、⽆连接的 UDP。

这两种协议的差别

TCP 是可靠的，UDP 是不可靠的。

<img src="/img/ip/ip-transport-tcp-udp.jpg"  alt="tcp" />      

#### UDP 

UDP 的主要特点  

1、不需要建⽴连接：减少开销和发送数据之前的时延；  

2、尽最⼤努⼒交付：即不保证可靠交付；  

3、⾯向报⽂的：⼀次交付⼀个完整的报⽂，保留原始报⽂的边界；  

- 发送方的 UDP 程序对应用程序交下来的报文，添加首部后，就向下交付 IP 层。UDP 对应应用层交下来的报文，即不合并也不拆分，而是保留这些报文的边界。也就是说，应用层交给 UDP 多长的报文，UDP 就照样发，即一次发送一个报文。 

- 接收方的 UDP ，对于 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动的交付给上层的应用进程。也就是说 UDP 一次交付一个完整的报文。   

4、没有拥塞控制：⽹络出现拥塞不会降低源主机的发送速率；对某些实时应⽤是很重要的。  

5、⽀持多种交互通信： • ⽀持⼀对⼀、⼀对多、多对⼀和多对多的交互通信。  

6、⾸部开销⼩：8 个字节，⽐ TCP 的 20 个字节的⾸部要短。  

UDP 多对一  

<img src="/img/ip/ip-transport-udp-more.jpg"  alt="tcp" />        

UDP 的使用场景  

可以重复请求信息的情况下：  

- 例如：RIP，DNS，DHCP等；  

⼀次性传⼩量数据的应⽤（⾯向报⽂的）  

- 实时应⽤： • IP电话、视频会议等；  

- 多媒体应⽤。

#### TCP

1、TCP 是面向连接的运输层协议。也就是说，应用程序在使用 TCP 之前，必须先建立 TCP 连接，在传送送数据完成时，必须释放已经建立的连接。    

2、每一条 TCP 连接只能有连个端点，TCP 连接是点对点的（⼀对⼀）；  

3、TCP 提供可靠的交付服务。通过 TCP 连接传送的数据，无差错，不丢失不重复，并且按时到达。     

4、TCP 提供全双工通信。TCP 允许通信的双方的应用进程在任何时候都能发送数据；  

5、面向字节流。TCP 中的流值得是流入进程和从进程流出的字节序列。  

- 面向字节流的含义：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应⽤程序交下来的数据看成仅仅是⼀连串⽆结构的字节流。

- TCP 并不知道所传送的字节的流的含义，TCP 不保证接收方收到的数据块和发送方应用程序所发出的数据块大小具有对应大小的关系。  

- 但是接收方应用程序收到的字节和发送方应用程序发出的字节流完全一样。   

接收方应用程序应该有能力识别收到的字节流，并把它还原成有意义的应用层数据。     

<img src="/img/ip/ip-transport-tcp-point.jpg"  alt="tcp" />        

##### TCP 的连接  

TCP 把连接作为最基本的抽象：每⼀条 TCP 连接有两个端点，TCP 连接的端点不是主机，不是主机的IP 地址，不是应⽤进程，也不是运输层的协议端⼝，TCP 连接的端点叫做套接字 (socket) 或插⼝，端⼝号拼接到 (`contatenated with`) IP 地址即构成了套接字。

`套接字 socket = (IP地址 : 端⼝号)`

`TCP 连接 ::= {socket1, socket2} = {(IP1: port1)，(IP2: port2)}`  

同一个 IP 地址可以有多个不同的 TCP 连接；  

同一个端口号也可以出现在多个不同的 TCP 连接中。  

### 可靠性传输原理

TCP 发送的报文段是交给 IP 层传送的，但是 IP 只能提供尽最大努力交付，简单的说就是 TCP 下面的网络层提供的是不可靠的传输。  

理想的传输条件有下面两个特点   

1、传输信道不产生差错；  

2、不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。   

但是实际的网络层都不具有上面的两个理想条件，必须使用一些可靠的传输协议，在不可靠的传输信道中实现可靠传输。   

#### 停止等待协议

停止等待：就是每发送完一个分组就停止发送，等待对方的确定。在收到确认后再发送下一个分组。      

无差错情况  

<img src="/img/ip/ip-transport-tcp-no-error.jpg"  alt="tcp" /> 

无差错的情况下是最简单的，只需要在每组数据发送完成之后，收到确认继续发送就行了。   

有差错情况  

接收方 B 会出现下面两种错误  

1、B 接收到 M1 检测出了差错，就丢弃 M1，其他什么也不做；  

2、M1 在传送的过程中丢失了，这时候 B 就获取不到，也什么也不用做；  

如果解决上面的两种情况呢？   

答案：超时重传。   

可靠传输协议是这样设计的，只要 A 超过了一段时候仍然没有收到确认，就认为刚刚发送的分组丢失了，因而重传前面发送过的分组。   

不过下面三个点需要注意下  

1、A 在发送完一个分组之后，必须暂时保留已发送的分组副本(在发生超时重传时使用),只有收到了响应的确认，才能清除暂时保留的副本。   

2、分组和确认分组都必须进⾏编号。这样才能明确是哪⼀个发送出去的分组收到了确认，⽽哪⼀个分组还没有收到确认；  

3、超时计时器设置的重传时间应当⽐数据在分组传输的平均往返时间更⻓⼀些。太长，通信的效率就会很低，太短了会导致没有必要的重传。   

确认丢失和确认迟到  

确认丢失  

A 在超时计时器到期后重传 M1，如果 B ⼜收到了重传的分组 M1：  

1、丢弃这个重复的分组 M1；  

2、向 A 发送确认。  

<img src="/img/ip/ip-transport-retran-lose.jpg"  alt="tcp" /> 

出现差错  

B 对分组 M1 的确认迟到了：   

1、B 丢弃重复的 M1，并重传确认分组；  

2、A 会收到重复的确认：收下后就丢弃。

<img src="/img/ip/ip-transport-retran-err.jpg"  alt="tcp" />    

总结下：  

通常 A 最终总是可以收到对所有发出的分组的确认；  

如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进⾏通信；   

使⽤上述的确认和重传机制，我们就可以在不可靠的传输⽹络上，实现可靠的通信；  

上述协议称为自动重传请求 ARQ，意思就是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。     

#### 信道利用率

停止等待协议的优点是简单，缺点也很明显，信道的利用率太低了。   

<img src="/img/ip/ip-transport-channel-used.jpg"  alt="tcp" /> 

来总结下停止等待协议的要点  

- 停⽌等待。发送⽅每次只发送⼀个分组。在收到确认后再发送下⼀个分组；  

- 编号。对发送的每个分组和确认都进⾏编号；  

- ⾃动重传请求。发送⽅为每个发送的分组设置⼀个超时计时器。若超时计时器超时，发送⽅会⾃动重传分组；  

- 简单，但信道利⽤率太低。   

为了提高传输效率，可以不使低效率的停止等待协议，而是采用流水线传输。   

流水线传输，就是发送方可以连续发送多个分组，不必每次发送完成就停顿下来等待对方的确认。这样可以使信道上一直有数据不断在传送，这种方式可以提高信道的利用率。  

<img src="/img/ip/ip-transport-channel-arq.jpg"  alt="tcp" /> 

当使⽤流⽔线传输时，连续ARQ协议和滑动窗⼝协议：限制连续发送数据的量。   

##### 连续 ARQ 协议  

<img src="/img/ip/ip-transport-channel-continuous-arq.jpg"  alt="tcp" />   

连续 ARQ 协议规定，发送方每收到一个确认，就把窗口向前活动一个分组位置。  

接收方一般采用累计确认的方式。就是接收方不必对收到的分组进行逐一确认，而是在收到几个分组之后，对按序到达的最后一个分组发送确认。表示这个分组为止的所有分组都已经正确收到了。   

优点：容易实现，即使确认丢失也不必重传。  

缺点：不能向发送方反应出接收方已经正确收到所有分组信息。      

**Go-back-N（回退 N）**  

发送⽅发送了前 5 个分组，第 3 个分组丢失，接收⽅对收到1、2分组发出确认，发送⽅⽆法知道3、4、5的下落，只好把这三个分组再重传⼀次。   

这就叫做 `Go-back-N（回退 N）`，表示需要再退回来重传已经发送的 N 个分组。所以当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。  

滑动窗口的具体细节，看下文  

### TCP 报文段的首部格式

TCP 虽然是面向字节流的，但是 TCP 的传送单元式报文段。    

一个 TCP 分成首部和数据两部分，TCP 的全部功能体现在首部的各字段的作用。所以有必要弄清除这几个字段的作用。  






### 参考

【极客时间-趣谈网络协议】https://time.geekbang.org/column/intro/100007101  
【计算机网络第八版】https://www.bilibili.com/video/BV1WP4y1j7JU?p=1  
【计算机网络学习笔记】https://github.com/boilingfrog/Go-POINT/tree/master/tcp     






