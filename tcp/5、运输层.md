<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [运输层](#%E8%BF%90%E8%BE%93%E5%B1%82)
  - [为什么需要运输层](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%90%E8%BE%93%E5%B1%82)
  - [TCP 和 UDP](#tcp-%E5%92%8C-udp)
    - [UDP](#udp)
    - [TCP](#tcp)
      - [TCP 的连接](#tcp-%E7%9A%84%E8%BF%9E%E6%8E%A5)
  - [可靠性传输原理](#%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86)
    - [停止等待协议](#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE)
    - [信道利用率](#%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87)
      - [连续 ARQ 协议](#%E8%BF%9E%E7%BB%AD-arq-%E5%8D%8F%E8%AE%AE)
  - [TCP 报文段的首部格式](#tcp-%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F)
  - [TCP 可靠传输的实现](#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0)
    - [TCP 流量控制](#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 运输层

### 为什么需要运输层

运输层（传输层），解决的是计算机程序到计算机程序之间的通信问题，即所谓的“端”到 “端”的通信。    

⽹络层最终解决的问题：

分组从⼀台主机经过⽹络到达另⼀台主机，即主机到主机间的通信。

⽹络层没有解决的问题： 

1、主机中谁发送的数据、谁接收数据；  

2、IP分组⽆序到达⽬的主机，接收进程如何处理；  

3、可靠传输问题。  

引入传输层的原因： 

1、增加复用和分用的功能；  

2、消除网络层的不可靠性；  

3、提供从源端主机到目的端主机的可靠的、与实际使用的网络无关的信息传输。      

<img src="/img/ip/ip-transport-effect.jpg"  alt="tcp" />

进程之间的通信  

从 IP 的角度，通信的两端是两台主机。但“两台主机之间的通信”这种说法还不够清楚；严格地讲，两台主机进⾏通信就是两台主机中的应⽤进程互相通信；  

从运输层的⻆度看，通信的真正端点并不是主机⽽是主机中的进程。也就是说，端到端的通信是应⽤进程之间的通信。  

网络层和运输层的区别  

<img src="/img/ip/ip-transport-different-with-network.jpg"  alt="tcp" />  

### TCP 和 UDP 

根据应⽤程序的不同需求，运输层需要有两种不同的运输协议：

1、即⾯向连接的 TCP；

2、⽆连接的 UDP。

这两种协议的差别

TCP 是可靠的，UDP 是不可靠的。

<img src="/img/ip/ip-transport-tcp-udp.jpg"  alt="tcp" />      

#### UDP 

UDP 的主要特点  

1、不需要建⽴连接：减少开销和发送数据之前的时延；  

2、尽最⼤努⼒交付：即不保证可靠交付；  

3、⾯向报⽂的：⼀次交付⼀个完整的报⽂，保留原始报⽂的边界；  

- 发送方的 UDP 程序对应用程序交下来的报文，添加首部后，就向下交付 IP 层。UDP 对应应用层交下来的报文，即不合并也不拆分，而是保留这些报文的边界。也就是说，应用层交给 UDP 多长的报文，UDP 就照样发，即一次发送一个报文。 

- 接收方的 UDP ，对于 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动的交付给上层的应用进程。也就是说 UDP 一次交付一个完整的报文。   

4、没有拥塞控制：⽹络出现拥塞不会降低源主机的发送速率；对某些实时应⽤是很重要的。  

5、⽀持多种交互通信： • ⽀持⼀对⼀、⼀对多、多对⼀和多对多的交互通信。  

6、⾸部开销⼩：8 个字节，⽐ TCP 的 20 个字节的⾸部要短。  

UDP 多对一  

<img src="/img/ip/ip-transport-udp-more.jpg"  alt="tcp" />        

UDP 的使用场景  

可以重复请求信息的情况下：  

- 例如：RIP，DNS，DHCP等；  

⼀次性传⼩量数据的应⽤（⾯向报⽂的）  

- 实时应⽤： • IP电话、视频会议等；  

- 多媒体应⽤。

#### TCP

1、TCP 是面向连接的运输层协议。也就是说，应用程序在使用 TCP 之前，必须先建立 TCP 连接，在传送送数据完成时，必须释放已经建立的连接。    

2、每一条 TCP 连接只能有连个端点，TCP 连接是点对点的（⼀对⼀）；  

3、TCP 提供可靠的交付服务。通过 TCP 连接传送的数据，无差错，不丢失不重复，并且按时到达。     

4、TCP 提供全双工通信。TCP 允许通信的双方的应用进程在任何时候都能发送数据；  

5、面向字节流。TCP 中的流值得是流入进程和从进程流出的字节序列。  

- 面向字节流的含义：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应⽤程序交下来的数据看成仅仅是⼀连串⽆结构的字节流。

- TCP 并不知道所传送的字节的流的含义，TCP 不保证接收方收到的数据块和发送方应用程序所发出的数据块大小具有对应大小的关系。  

- 但是接收方应用程序收到的字节和发送方应用程序发出的字节流完全一样。   

接收方应用程序应该有能力识别收到的字节流，并把它还原成有意义的应用层数据。     

<img src="/img/ip/ip-transport-tcp-point.jpg"  alt="tcp" />        

##### TCP 的连接  

TCP 把连接作为最基本的抽象：每⼀条 TCP 连接有两个端点，TCP 连接的端点不是主机，不是主机的IP 地址，不是应⽤进程，也不是运输层的协议端⼝，TCP 连接的端点叫做套接字 (socket) 或插⼝，端⼝号拼接到 (`contatenated with`) IP 地址即构成了套接字。

`套接字 socket = (IP地址 : 端⼝号)`

`TCP 连接 ::= {socket1, socket2} = {(IP1: port1)，(IP2: port2)}`  

同一个 IP 地址可以有多个不同的 TCP 连接；  

同一个端口号也可以出现在多个不同的 TCP 连接中。  

### 可靠性传输原理

TCP 发送的报文段是交给 IP 层传送的，但是 IP 只能提供尽最大努力交付，简单的说就是 TCP 下面的网络层提供的是不可靠的传输。  

理想的传输条件有下面两个特点   

1、传输信道不产生差错；  

2、不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。   

但是实际的网络层都不具有上面的两个理想条件，必须使用一些可靠的传输协议，在不可靠的传输信道中实现可靠传输。   

#### 停止等待协议

停止等待：就是每发送完一个分组就停止发送，等待对方的确定。在收到确认后再发送下一个分组。      

无差错情况  

<img src="/img/ip/ip-transport-tcp-no-error.jpg"  alt="tcp" /> 

无差错的情况下是最简单的，只需要在每组数据发送完成之后，收到确认继续发送就行了。   

有差错情况  

接收方 B 会出现下面两种错误  

1、B 接收到 M1 检测出了差错，就丢弃 M1，其他什么也不做；  

2、M1 在传送的过程中丢失了，这时候 B 就获取不到，也什么也不用做；  

如果解决上面的两种情况呢？   

答案：超时重传。   

可靠传输协议是这样设计的，只要 A 超过了一段时候仍然没有收到确认，就认为刚刚发送的分组丢失了，因而重传前面发送过的分组。   

不过下面三个点需要注意下  

1、A 在发送完一个分组之后，必须暂时保留已发送的分组副本(在发生超时重传时使用),只有收到了响应的确认，才能清除暂时保留的副本。   

2、分组和确认分组都必须进⾏编号。这样才能明确是哪⼀个发送出去的分组收到了确认，⽽哪⼀个分组还没有收到确认；  

3、超时计时器设置的重传时间应当⽐数据在分组传输的平均往返时间更⻓⼀些。太长，通信的效率就会很低，太短了会导致没有必要的重传。   

确认丢失和确认迟到  

确认丢失  

A 在超时计时器到期后重传 M1，如果 B ⼜收到了重传的分组 M1：  

1、丢弃这个重复的分组 M1；  

2、向 A 发送确认。  

<img src="/img/ip/ip-transport-retran-lose.jpg"  alt="tcp" /> 

出现差错  

B 对分组 M1 的确认迟到了：   

1、B 丢弃重复的 M1，并重传确认分组；  

2、A 会收到重复的确认：收下后就丢弃。

<img src="/img/ip/ip-transport-retran-err.jpg"  alt="tcp" />    

总结下：  

通常 A 最终总是可以收到对所有发出的分组的确认；  

如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进⾏通信；   

使⽤上述的确认和重传机制，我们就可以在不可靠的传输⽹络上，实现可靠的通信；  

上述协议称为自动重传请求 ARQ，意思就是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。     

#### 信道利用率

停止等待协议的优点是简单，缺点也很明显，信道的利用率太低了。   

<img src="/img/ip/ip-transport-channel-used.jpg"  alt="tcp" /> 

来总结下停止等待协议的要点  

- 停⽌等待。发送⽅每次只发送⼀个分组。在收到确认后再发送下⼀个分组；  

- 编号。对发送的每个分组和确认都进⾏编号；  

- ⾃动重传请求。发送⽅为每个发送的分组设置⼀个超时计时器。若超时计时器超时，发送⽅会⾃动重传分组；  

- 简单，但信道利⽤率太低。   

为了提高传输效率，可以不使低效率的停止等待协议，而是采用流水线传输。   

流水线传输，就是发送方可以连续发送多个分组，不必每次发送完成就停顿下来等待对方的确认。这样可以使信道上一直有数据不断在传送，这种方式可以提高信道的利用率。  

<img src="/img/ip/ip-transport-channel-arq.jpg"  alt="tcp" /> 

当使⽤流⽔线传输时，连续ARQ协议和滑动窗⼝协议：限制连续发送数据的量。   

##### 连续 ARQ 协议  

<img src="/img/ip/ip-transport-channel-continuous-arq.jpg"  alt="tcp" />   

连续 ARQ 协议规定，发送方每收到一个确认，就把窗口向前活动一个分组位置。  

接收方一般采用累计确认的方式。就是接收方不必对收到的分组进行逐一确认，而是在收到几个分组之后，对按序到达的最后一个分组发送确认。表示这个分组为止的所有分组都已经正确收到了。   

优点：容易实现，即使确认丢失也不必重传。  

缺点：不能向发送方反应出接收方已经正确收到所有分组信息。      

**Go-back-N（回退 N）**  

发送⽅发送了前 5 个分组，第 3 个分组丢失，接收⽅对收到1、2分组发出确认，发送⽅⽆法知道3、4、5的下落，只好把这三个分组再重传⼀次。   

这就叫做 `Go-back-N（回退 N）`，表示需要再退回来重传已经发送的 N 个分组。所以当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。  

滑动窗口的具体细节，看下文  

### TCP 报文段的首部格式

TCP 虽然是面向字节流的，但是 TCP 的传送单元式报文段。    

一个 TCP 分成首部和数据两部分，TCP 的全部功能体现在首部的各字段的作用。所以有必要弄清除这几个字段的作用。  

TCP 报⽂段⾸部的前20个字节是固定的，后⾯有 4n 字节是根据需要⽽增加的选项。   

<img src="/img/ip/ip-transport-tcp-header.jpg"  alt="tcp" />    

1、源端口和目的端口：各占 2 个字节，分别写入源端口号和目的端口号，是运输层与应用层的服务接口；    

2、序号：4 字节，也称报文段序号，指报文段所携带数据的第一个字节的序号；  

- TCP 是面向字节流的，在一个 TCP 连接中传送的字节流的每一个字节都按序号进行编号，整个要传送的字节流的起始序号必须在连接建立时设置。  

- **栗子**

- 一报文段的序号字段值是 301，携带的数据是 100 字节。这表示本报文段，第一个字节的序号是 301， 最后一个字节的序号是 400 。  

- 下一个报文段的数据序号应该从 401 开始。  

3、确认号：4 个字节，是期望收到对方下一个报文段的第一个字节的序号。

- 这里有个规律，若确认号是 N，就表明到序号 N -1 之前的数据都已正确收到了。  

4、数据偏移：占 4 位，它指出 TCP 报⽂段的数据起始处距离 TCP 报⽂段的起始处有多远，实际上指的是 TCP 报文段的首部长度；   

5、保留：占 6 位，保留为今后使用，目前应该置为 0；  

6、紧急 URG :当 URG = 1 时，紧急指针字段有效，此报⽂段中有紧急数据，应尽快传送;  

- 栗如：当我们想要结束程序的执行使用中断命令(control + c),如果不使用紧急数据，那么这个命令就会存储在接收 TCP 的缓存末尾，只有等待前面的所有数据被处理完成之后，这两个字符才会被交付给接收方的应用程序、   

7、确认 ACK：只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号⽆效, TCP 规定在连接后所有传送的报文都必须把 ACK 置为 1；  

8、推送 PSH(PuSH):收到 PSH = 1 的报⽂段，发送⽅⽴即发送，接收⽅尽快上交接收应⽤进程；   

9、当 RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建⽴运输连接；   

10、同步 SYN: SYN = 1 表示这是一个连接请求或连接接受报文；  

11、终止 FIN: 用来释放一个链接，FIN = 1,表示此报文段的发送端的数据已经发送完毕，并要求释放运输连接；  

12、窗口：占 2 个字节，让对方设置发送窗口的依据，单位为字节，`[ 0, 216 – 1 ]` 之间的整数，主要作用是告诉对⽅，从本报⽂段⾸部中的确认号算起，接收⽅⽬前允许对⽅发送的数据量；  

- 为什么需要这个限制呢，是因为数据缓存空间是有限的，窗口值，可以作为接收方设置发送串口的依据。   

13、校验和：占 2 个字节，检验和字段检验的范围包括⾸部和数据这两部分。在计算检验和时，要在 TCP 报⽂段的前⾯加上 12 字节的伪⾸部；  

14、紧急指针：占 2 个字节，紧急指针仅在 URG = 1 时才有意义，它指出本报文段中紧急数据的字节数，(紧急数据结束后就是普通数据)；  

15、选项：长度可变，TCP 最初只有⼀种选项，即最⼤报⽂段⻓度 MSS。MSS 告诉对⽅ TCP：“我的缓存所能接收的报⽂段的数据字段的最⼤⻓度是 MSS 个字节。”

### TCP 可靠传输的实现

TCP 连接中的连个端点都有两个窗口：  

发送窗口：准备发送的数据和已经发送但未收到确认的数据;  

接收窗口：按序到达但未被程序接收的数据、不按序到达的数据；  

TCP 两端的四个窗口经常处于动态变化中。  

TCP 的可靠传输是用字节的序号进行控制。TCP 中所有的确认都是基于序号而不是基于报文段的。   

TCP连接的往返时间 RTT 不是固定不变的，需要使⽤特定的算法估算较为合理的重传时间。  

来看下具体滑动窗口的实现  

<img src="/img/ip/ip-transport-slide-windows.jpg"  alt="tcp" />    

1、发送方根据**确认号**和**窗口**值的大小，就能确定自己的发送窗口；  

2、发送放可以把落入滑动窗口中的序号字节一次性全部发送出去，边发送边接收；  

3、如果数据全部发送完成，但是没有收到确认，那么就需要停止发送，这时候的有效窗口就是0；  

<img src="/img/ip/ip-transport-slide-windows-ack.jpg"  alt="tcp" />    

4、发送窗口中，收到了确认号，那么就根据当前最新的确认号和窗口大小来调整活动窗口，将新的字节划入到滑动窗口中；   

- 这里有个规律，若确认号是 N，就表明到序号 N -1 之前的数据都已正确收到了。

<img src="/img/ip/ip-transport-slide-windows-new.jpg"  alt="tcp" />

5、接收窗口在收到数据后，会对按序收到的数据中的最高序号给出确认，这样就保证发送窗口中，收到的确认号前面的数据都已经被接收窗口收到了；  

<img src="/img/ip/ip-transport-slide-windows-received.jpg"  alt="tcp" />

6、如果发送端经过一段时候没有收到确认，就会使用超时控制器，来重传这一部分的数据，重新设置超时间，直到收到接收端的确认。  

#### TCP 流量控制 

为什么需要流量控制，我们总是希望数据传输能快一点，但是如果发送方，发送过快，接收方来不及处理，这就会造成数据的丢失。   

流量控制就是让发送方的发送频率不要太快，接收方来得及接收处理。   

可以使用滑动窗口来实现流量控制，通过接收方的接收能力来限制发送方的发送能力。    




### 参考

【极客时间-趣谈网络协议】https://time.geekbang.org/column/intro/100007101  
【计算机网络第八版】https://www.bilibili.com/video/BV1WP4y1j7JU?p=1  
【计算机网络学习笔记】https://github.com/boilingfrog/Go-POINT/tree/master/tcp     






