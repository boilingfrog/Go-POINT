## MongoDB 中的锁

### 前言

MongoDB 是一种常见的文档型数据库，因为其高性能、高可用、高扩展性等特点，被广泛应用于各种场景。   

在多线程的访问下，可能会出现多线程同时操作一个集合的情况，进而出现数据冲突的情况，为了保证数据的一致性，MongoDB 采用了锁机制来保证数据的一致性。   

下面来看看 MongoDB 中的锁机制。   

### MongoDB 中锁的类型

MongoDB 中使用多粒度锁定，它允许操作锁定在全局，数据库或集合级别，同时允许各个存储引擎在集合级别一下实现自己的并发控制(例如，WiredTiger 中的文档级别)。    

在 MongoDB 中，有四个级别的锁定：  

1、全局级锁定：这也称为实例级锁定。 这意味着所有数据库都将被锁定；  

2、数据库级锁定：只有指定的数据库才会在这种类型的锁定中被锁定；  

3、集合级锁：在 MongoDB 中，集合是一组相关的文档（类似于传统 RDBMS 中的表）。集合级锁定句柄锁定单个集合；   

4、文档级锁定：MongoDB 中的文档可以称为具有字段和值对的记录。 这种类型的锁定仅锁定特定文档。   

MongoDB 中使用一个 readers-writer 锁，它允许并发多个读操作访问数据库，但是只提供唯一写操作访问。    

当一个读锁存在时，其它的读操作可以继续，不会被阻塞，如果一个写锁占有这个资源的时候，其它所有的读操作和写操作都会被阻塞。也就是读读不阻塞，读写阻塞，写写阻塞。    

锁是 `写贪婪` 这意味着写操作锁比读操作具有优先权，当写操作和读操作同时等待一个锁，MongoDB 会授予读操作这个锁。   

MongoDB 中的锁首先提供了读写锁，即共享锁（Shared, S）（读锁）以及排他锁（Exclusive, X）（写锁），同时，为了解决多层级资源之间的互斥关系，提高多层级资源请求的效率，还在此基础上提供了意向锁（Intent Lock）。即锁可以划分为4中类型：   

1、共享锁，读锁，允许多个线程同时读取一个集合，读读不互斥；   

2、排他锁，写锁，允许一个线程写入数据，写写互斥，读写互斥；   

3、意向共享锁，IS，表示意向读取；  

4、意向排他锁，IX，表示意向写入；  

什么是意向锁呢？

如果另一个任务企图在某表级别上应用共享或排他锁，则受由第一个任务控制的表级别意向锁的阻塞，第二个任务在锁定该表前不需要检查各个页或行锁，而只需检查表上的意向锁。   

简单的讲就是意向锁是为了快速判断，表里面是否有记录被加锁。     

对于大多数读取和写入操作，WiredTiger 使用乐观并发控制。WiredTiger 仅在全局，数据库和集合层面使用意向锁。当存储引擎检测到两个操作之间存在冲突的时候，
将引发冲突，从而导致 MongoDB 对用户透明的重试该操作。   

在某些情况下，读和写可以产生自己的锁。   

长期运行的读操作和写操作，比如查询，更新，删除，在很多情况下会产生锁。MongoDB 如果修改单个文档的操作，带有 multi 参数修改多个文档 update()操作，MongoDB 也会产生锁定。    

对于文档级别并发访问控制的存储引擎（例如WiredTiger），当使用意向锁访问存储时，不需要锁定，因为该锁是数据库和集合级别的全局锁定，不会阻塞其他读取和写入操作。但是操作将定期产生锁定，为什么会定期产生锁呢：

避免长时间执行的存储性事务，这些事务可能会在内存中保存大量的数据，定期添加锁，可以作为中断的响应点，可以方便我们取消长时间执行的语句操作，同时方便了有排它访问的操作，例如索引/集合删除和创建。   




#### MongoDB 中的锁级别



共享锁(Shared Lock):允许多个线程同时读取一个集合


### 参考

【mongodb锁表命令-相关文档】https://www.volcengine.com/theme/900385-M-7-1   
【mongo 中的锁】https://www.jinmuinfo.com/community/MongoDB/docs/15-faq/03-concurrency.html  