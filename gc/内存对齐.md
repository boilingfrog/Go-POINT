<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [内存对齐](#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90)
  - [什么是内存对齐](#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90)
  - [为什么需要内存对齐](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90)
  - [对齐规则](#%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 内存对齐

### 什么是内存对齐

弄明白什么是内存对齐的时候，先来看一个demo  

```go
type s struct {
	Bool  bool
	Byte  byte
	In32  int32
	Int64 int64
	Int8  int8
}

func main() {
	fmt.Printf("bool size: %d\n", unsafe.Sizeof(bool(true)))
	fmt.Printf("int32 size: %d\n", unsafe.Sizeof(int32(0)))
	fmt.Printf("int8 size: %d\n", unsafe.Sizeof(int8(0)))
	fmt.Printf("int64 size: %d\n", unsafe.Sizeof(int64(0)))
	fmt.Printf("byte size: %d\n", unsafe.Sizeof(byte(0)))
	fmt.Printf("string size: %d\n", unsafe.Sizeof("E"))

	part1 := s{}
	fmt.Printf("part1 size: %d, align: %d\n", unsafe.Sizeof(part1), unsafe.Alignof(part1))
}
```

打印下输出  

```go
bool size: 1
int32 size: 4
int8 size: 1
int64 size: 8
byte size: 1
string size: 16

part1 size: 24, align: 8
```

按照不能类型的长度计算，结构体`s`的长度应该是`1+1+4+8+1=15`，但是我们通过`unsafe.Sizeof()`计算出来的长度是24。这就是发生了内存对齐造成的。  

现代计算机中内存空间都是按照`byte`划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是内存对齐。  

### 为什么需要内存对齐

1、平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。  

2、性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。  

### 对齐规则  

在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令`#pragma pack(n)`进行变更，n就是代指 “对齐系数”。  

一般来讲，我们常用的平台的系数如下：  

- 32 位：4

- 64 位：8

查看几种类型的对齐系数  



1、对于结构的各个成员，第一个成员位于偏移为0的位置，以后每个数据成员的起始位置必须是默认对齐长度和该数据成员长度中最小的长度的倍数。  

2、除了结构成员需要对齐，结构本身也需要对齐，结构的长度必须是编译器默认的对齐长度和成员中最长类型中最小的数据大小的倍数对齐。  

我们根据上面的例子具体的分析下  

```go
type s struct {
	Bool  bool
	Byte  byte
	In32  int32
	Int64 int64
	Int8  int8
}
```

**成员对齐**  

规则一  

- 第一个成员`Bool`  
    - 类型: bool
    - 大小/对齐值: 1
    - 占用地址空间: 0~1
    




1. bool的大小是1byte
2. bool的大小是1byte






### 参考
【在 Go 中恰到好处的内存对齐】https://eddycjy.gitbook.io/golang/di-1-ke-za-tan/go-memory-align   
【golang 内存对齐】https://xie.infoq.cn/article/594a7f54c639accb53796cfc7   
【C/C++内存对齐详解】https://zhuanlan.zhihu.com/p/30007037  
【内存对齐详解】https://developer.aliyun.com/article/32177  
【go内存对齐】https://www.kancloud.cn/golang_programe/golang/1144263  