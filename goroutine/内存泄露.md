<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [内存泄露](#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [goroutine的退出](#goroutine%E7%9A%84%E9%80%80%E5%87%BA)
    - [发送端channel满了](#%E5%8F%91%E9%80%81%E7%AB%AFchannel%E6%BB%A1%E4%BA%86)
    - [接收端消费的channel为空](#%E6%8E%A5%E6%94%B6%E7%AB%AF%E6%B6%88%E8%B4%B9%E7%9A%84channel%E4%B8%BA%E7%A9%BA)
    - [生产者消费者异常退出，导致没有消费者或没有发送者的情况出现](#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA%E5%AF%BC%E8%87%B4%E6%B2%A1%E6%9C%89%E6%B6%88%E8%B4%B9%E8%80%85%E6%88%96%E6%B2%A1%E6%9C%89%E5%8F%91%E9%80%81%E8%80%85%E7%9A%84%E6%83%85%E5%86%B5%E5%87%BA%E7%8E%B0)
    - [channel未初始化](#channel%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96)
    - [未添加超时处理](#%E6%9C%AA%E6%B7%BB%E5%8A%A0%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86)
  - [使用pprof排查](#%E4%BD%BF%E7%94%A8pprof%E6%8E%92%E6%9F%A5)
    - [什么是pprof](#%E4%BB%80%E4%B9%88%E6%98%AFpprof)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 内存泄露

### 前言

go中的内存泄露一般都是goroutine泄露，就是goroutine没有被关闭，或者没有添加超时控制，让goroutine一只处于阻塞状态，不能被GC。  

### goroutine内存泄露

首先明确一点  

**关闭不再需要使用的 channel 并不是必须的**
 
跟其他资源比如打开的文件、socket 连接不一样，这类资源使用完后不关闭后会造成句柄泄露，channel 使用完后不关闭也没有关系，channel 没有被任何协程用到后最终会被 GC 回收。关闭 channel 一般是用来通知其他协程某个任务已经完成了。  

也就是有goroutine引用的channel，是不会被gc，并且channel会使当前引用的goroutine一直阻塞，直到接收到退出的信号。  

#### 发送端channel满了

goroutine作为生产者向 channel发送信息，但是没有消费的goroutine，或者消费的goroutine被错误的关闭了。导致channel被打满。    

```go
func channelNoProducter() {
	ch := make(chan int)
	go func() {
		ch <- 1
		fmt.Println(111)
	}()
}
```

没有消费者，当channel满了，发送端的goroutine就会一直阻塞，直到channel被下游的消费者消费掉。  

#### 接收端消费的channel为空

作为消费者的goroutine,等待消费channel，但是上游的生产者不存在  

```go
func channelNoProducer() {
	ch := make(chan int, 1)
	go func() {
		<-ch
		fmt.Println(111)
	}()
}
```

goroutine等待消费channel,但是一直读取不到数据就会一直处于阻塞状态  

#### 生产者消费者异常退出，导致channel满了或者channel为空

作为生产者的goroutine如果没有数据发送了，就需要主动退出当前的goroutine,并且发出退出信号，这样下游消费的goroutine,才能在channel消费完的时候，优雅的退出，不至于阻塞在没有发送者的channel中。  

作为消费者的goroutine一定要在channel没数据了，并且上游发送数据的goroutine已经退出的情况下，退出。这样，才不至于上游的发送者阻塞到一个没有消费者的channel中。  

具体的发送关闭策略可参考<a href="https://www.cnblogs.com/ricklz/p/13813201.html#channel%E7%9A%84%E5%85%B3%E9%97%AD" target="_blank">channel的关闭</a>

#### channel未初始化

````go
func main() {
	var ch chan int

	go func(ch chan int) {
		<-ch
	}(ch)

	c := time.Tick(1 * time.Second)
	for range c {
		fmt.Printf("#goroutines: %d", runtime.NumGoroutine())
	}
}
````

channel未初始化，无论发送数据还是从里面接收数据，都会出现阻塞的情况

#### 未添加超时处理

当然这不是goroutine泄露的原因，只是一个防止goroutine不能及时推出的处理策略  

下面总结下超时处理的集中方案  

**使用context.WithTimeout**

```go
func TimeoutCancelContext() {
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(time.Millisecond*800))
	go func() {
		// 具体的业务逻辑
		// 取消超时
		defer cancel()
	}()

	select {
	case <-ctx.Done():
		fmt.Println("time out!!!")
		return
	}
}
```

1、通过context的WithTimeout设置一个有效时间为1000毫秒的context。  

2、业务逻辑完成会调用cancel(),取消超时，如果在设定的超时时间内，业务阻塞没有完成，就会触发超时的退出。  

**使用channel**

```go
func TimeoutCancelChannel() {
	done := make(chan struct{}, 1)

	go func() {
		// 执行业务逻辑
		done <- struct{}{}
	}()

	select {
	case <-done:
		fmt.Println("call successfully!!!")
		return
	case <-time.After(time.Duration(800 * time.Millisecond)):
		fmt.Println("timeout!!!")
		// 使用独立的协程处理超时，需求添加return退出协程，否则会导致当前协程被通知channel阻塞，进而导致内存泄露
		return
	}
}
```

1、使用channel接收业务完成的通知  

2、业务执行阻塞超过设定的超时时间，就会触发超时退出。  

### 使用pprof排查

#### 什么是pprof

pprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是CPU使用情况、内存使用情况、goroutine运行情况等，当需要性能调优或者定位Bug时候，这些记录的信息是相当重要。  

基本使用  

GO中已经封装好了，直接就能使用`_ "net/http/pprof"`  

````go
package main

import (
	"fmt"
	"net/http"
	_ "net/http/pprof"
)

func main() {
	// 开启pprof，监听请求
	ip := "127.0.0.1:6069"
	if err := http.ListenAndServe(ip, nil); err != nil {
		fmt.Printf("start pprof failed on %s\n", ip)
	}
}
````

浏览器查看  

浏览器访问就能看到效果  
```
http://127.0.0.1:6069/debug/pprof/
```

<img src="/img/pprof_1.jpg"  alt="pprof" align="center" />

看下集体参数的含义  

- allocs: A sampling of all past memory allocations
- block: Stack traces that led to blocking on synchronization primitives
- cmdline: The command line invocation of the current program
- goroutine: Stack traces of all current goroutines
- heap: A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample.
- mutex: Stack traces of holders of contended mutexes
- profile: CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile.
- threadcreate: Stack traces that led to the creation of new OS threads
- trace: A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace.

### 参考
【channel关闭的注意事项】https://studygolang.com/articles/16893  
【Golang 中的并发限制与超时控制】https://www.jianshu.com/p/42e89de33065  
【Golang中WaitGroup、Context、goroutine定时器及超时学习笔记】https://segmentfault.com/a/1190000009602670  
【实战Go内存泄露】https://segmentfault.com/a/1190000019222661  
 