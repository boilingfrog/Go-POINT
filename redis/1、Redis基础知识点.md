<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [Redis 基础知识点](#redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9)
  - [为什么 Redis 比较快](#%E4%B8%BA%E4%BB%80%E4%B9%88-redis-%E6%AF%94%E8%BE%83%E5%BF%AB)
  - [Redis 中的数据结构](#redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
    - [简单动态字符串](#%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2)
      - [SDS 对比 c 字符串的优势](#sds-%E5%AF%B9%E6%AF%94-c-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BC%98%E5%8A%BF)
      - [1、SDS可以常数级别获取字符串的长度](#1sds%E5%8F%AF%E4%BB%A5%E5%B8%B8%E6%95%B0%E7%BA%A7%E5%88%AB%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6)
      - [2、杜绝缓冲区溢出](#2%E6%9D%9C%E7%BB%9D%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA)
      - [3、减少修改字符串时带来的内存分配次数](#3%E5%87%8F%E5%B0%91%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%AC%A1%E6%95%B0)
      - [4、二进制安全](#4%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8)
      - [5、兼容部分C字符串函数](#5%E5%85%BC%E5%AE%B9%E9%83%A8%E5%88%86c%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0)
  - [为什么单线程还能很快](#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E8%83%BD%E5%BE%88%E5%BF%AB)
  - [基于多路复用的高性能I/O模型](#%E5%9F%BA%E4%BA%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BDio%E6%A8%A1%E5%9E%8B)
  - [单线程处理IO请求性能瓶颈](#%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86io%E8%AF%B7%E6%B1%82%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Redis 基础知识点

### 为什么 Redis 比较快 

Redis 中的查询速度为什么那么快呢？  

1、因为它是内存数据库；  

2、归功于它的数据结构；  

3、Redis 中是单线程；     

4、Redis 中使用了多路复用。  

### Redis 中的数据结构

#### 简单动态字符串

Redis 中并没有使用 C 中 char 来表示字符串，而是引入了 简单动态字符串（Simple Dynamic Strings，SDS）来存储字符串和整型数据。那么 SDS 对比传统的字符串有什么优点呢？   

先来看下 SDS 的结构  

```
struct sdshdr {
    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 保存字符串的长度，不包含'\0'
    long len;
    
    // 记录buf数组中未使用字节的数量
    long free;
    
    // 字节数组，用于保存字符串
    char buf[];
};
```

举个栗子：  

使用 SDS 存储了一个字符串 hello,对应的 len 就是5，同时也申请了5个为未使用的空间，所以 free 就是5。   

<img src="/img/redis-sds.png"  alt="redis" align="center" />

##### SDS 对比 c 字符串的优势

##### 1、SDS可以常数级别获取字符串的长度

因为结构里面已经记录了字符串的长度，所以获取字符串的长度复杂度为O(1)，c 中字符串没记录长度，需要遍历整个长度，复杂度为O(N)。  

##### 2、杜绝缓冲区溢出

如果在修改字符的时候，没有分配足够的内存大小，就很容易造成缓存溢出，内存越界。  

strcat 函数常见的错误就是数组越界，即两个字符串连接后，长度超过第一个字符串数组定义的长度，导致越界。  

SDS 中的空间分配策略可以杜绝这种情况，当对 SDS 进行修改时，API 会检查 SDS 的空间是否满足修改所需的要求，如果不满足的话，API 会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。空间的申请是自动完成的，所以就避免了缓存溢出。  

##### 3、减少修改字符串时带来的内存分配次数

对于 C 字符串来说，如果修改字符串的长度，都需要重新执行内存分配操作；但是对于 Redis 数据库来说，如果频繁执行内存分配/释放操作，必然会对性能产生一定影响。为了避免 C 字符串的缺陷，SDS 采用了空间预分配和惰性空间释放两种优化策略。  

**空间预分配**

空间预分配用于优化 SDS 的字符串增长操作，当 SDS 的 api 对 SDS 进行修改，同时需要进行空间扩展的时候，除了会给 SDS 分配修改需要的空间，同时还会给 SDS 分配额外的未使用空间。   

1、如果对 SDS 修改之后，SDS 的长度小于`1MB`,那么程序分配和 len 同样大小的未使用空间，也就是这时候 SDS 中的 len 和 free 长度相同；  

2、如果对 SDS 修改之后，SDS 的长度大于等于`1MB`,那么程序分配`1MB`的未使用空间。  

在对 SDS 空间进行扩展的时候，首先会判断未使用空间的大小是否能满足要求，如果足够，就不用在进行内存分配了，这样能够减少内存的重新分配的次数。   

**惰性空间释放**

惰性空间释放用于优化 SDS 字符串的缩短操作，当 SDS 的 API 需要缩短 SDS 保护的字符串时，程序并不会立即使用内存重分配来回收缩短后多出来的内存，而是使用 free 属性将这些字节的数量记录起来，等待之后的重新使用。   

##### 4、二进制安全

对于 C 字符串来说，字符串中不能包含空字符，否则最先被程序读入的空字符串被误认为是字符串结尾，这使得 C 字符串只能保存文本数据，而不能保存图片、音视频等二进制文件。对于 SDS 来说，所有 SDS 都会以处理二进制的方式来处理 SDS 保存在 buf 数组中的内容，程序不会对里面的内容做任何限制。  

##### 5、兼容部分C字符串函数

SDS 末尾设置空字符的操作使得它可以和部分 C 字符串函数兼容。  

### 为什么单线程还能很快

Redis 是单线程，主要是指 Redis 的网络IO和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。   

多线程必然会面临对于共享资源的访问，这时候通常的做法就是加锁，虽然是多线程，这时候就会变成串行的访问。也就是多线程编程模式会面临的共享资源的并发访问控制问题。  

同时多线程也会引入同步原语来保护共享资源的并发访问，代码的可维护性和易读性将会下降。   

### 基于多路复用的高性能I/O模型

Linux 中的IO多路复用机制是指一个线程处理多个IO流。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个IO流的效果。  

文件事件是对连接 socket 操作的一个抽象。当端口监听 socket 准备 accept 新连接，或者连接 socket 准备好读取请求、写入响应、关闭时，就会产生一个文件事件。IO 多路复用程序负责同时监听多个 socket，当这些 socket 产生文件事件时，就会触发事件通知，文件分派器就会感知并获取到这些事件。  

虽然多个文件事件可能会并发出现，但 IO 多路复用程序总会将所有产生事件的 socket 放入一个队列中，通过这个队列，有序的把这些文件事件通知给文件分派器。  

文件事件分派器接收 I/O 多路复用程序传来的套接字，并根据套接字产生的事件类型，调用相应的事件处理器。  

服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个的函数，他们定义了这个事件发生时，服务器应该执行的动作。  

<img src="/img/redis-multiple.png"  alt="redis" align="center" />

Redis 封装了 4 种多路复用程序，每种封装实现都提供了相同的 API 实现。编译时，会按照性能和系统平台，选择最佳的 IO 多路复用函数作为底层实现，选择顺序是，首先尝试选择 Solaries 中的 evport，如果没有，就尝试选择 Linux 中的 epoll，否则就选择大多 UNIX 系统都支持的 kqueue，这 3 个多路复用函数都直接使用系统内核内部的结构，可以服务数十万的文件描述符。  

如果当前编译环境没有上述函数，就会选择 select 作为底层实现方案。select 方案的性能较差，事件发生时，会扫描全部监听的描述符，事件复杂度是 O(n)，并且只能同时服务有限个文件描述符，32 位机默认是 1024 个，64 位机默认是 2048 个，所以一般情况下，并不会选择 select 作为线上运行方案。  

<img src="/img/redis-choose-multiple.png"  alt="redis" align="center" />

### 单线程处理IO请求性能瓶颈

**1、后台 Redis 通过监听处理事件队列中的消息，来单线程的处理命令，如果一个命令的执行时间很久，就会影响整个 server 的性能；**  

耗时的操作命令有下面几种：    

- 1、操作 bigkey：bigkey 在写入和删除的时候，需要的时间都会很长；   

- 2、使用复杂度过高的命令；  

- 3、大量 key 集中过期：Redis 的过期机制也是在主线程中执行的，大量 key 集中过期会导致处理一个请求时，耗时都在删除过期 key，耗时变长；    

- 4、淘汰策略：淘汰策略也是在主线程执行的，当内存超过 Redis 内存上限后，每次写入都需要淘汰一些 key，也会造成耗时变长；  

- 5、AO F刷盘开启 always 机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢 Redis 的性能；  
  
- 6、主从全量同步生成 RDB：虽然采用 fork 子进程生成数据快照，但 fork 这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；  

上面的这几种问题，我们在写业务的时候需要去避免，对于 bigkey，Redis 在4.0推出了 lazy-free 机制，把 bigkey 释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。  
 
**2、并发量非常大时，单线程读写客户端 IO 数据存在性能瓶颈**  

使用 Redis 时，几乎不存在 CPU 成为瓶颈的情况， Redis 主要受限于内存和网络。随着硬件水平的提升，Redis 中的性能慢慢主要出现在网络 IO 的读写上。虽然采用 IO 多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。   

为了提升网络 IO 的读写性能，Redis 在6.0推出了多线程，同过多线程的 IO 来处理网络请求。不过需要注意的是这里的多线程仅仅是针对客户端的读写是并行的，Redis 处理事件队列中的明亮，还是单线程处理的。   

### 参考

【Redis核心技术与实战】https://time.geekbang.org/column/intro/100056701    
【Redis6.0为什么引入多线程？】https://juejin.cn/post/7004683161695158309    
【Redis设计与实现】https://book.douban.com/subject/25900156/  
【redis---sds（简单动态字符串）详解】https://blog.csdn.net/u010765526/article/details/89065607    