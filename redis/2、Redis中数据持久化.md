<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [Redis 中数据的持久化](#redis-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [AOF 持久化](#aof-%E6%8C%81%E4%B9%85%E5%8C%96)
    - [什么是 AOF 持久化](#%E4%BB%80%E4%B9%88%E6%98%AF-aof-%E6%8C%81%E4%B9%85%E5%8C%96)
    - [为什么要后记录日志呢](#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%90%8E%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E5%91%A2)
    - [AOF 的潜在风险](#aof-%E7%9A%84%E6%BD%9C%E5%9C%A8%E9%A3%8E%E9%99%A9)
    - [AOF 文件的写入和同步](#aof-%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5%E5%92%8C%E5%90%8C%E6%AD%A5)
    - [AOF 文件重写机制](#aof-%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6)
  - [RDB 持久化](#rdb-%E6%8C%81%E4%B9%85%E5%8C%96)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Redis 中数据的持久化

### 前言

我们知道 Redis 是内存数据库，所有操作都在内存上完成。内存的话，服务器断电，内存上面的数据就会丢失了。这个问题显然是需要解决的。    

Redis 中引入了持久化来避免数据的丢失，主要有两种持久化的方式 RDB 持久化和 AOF 持久化。  

### AOF 持久化

#### 什么是 AOF 持久化

AOF(Append Only File):通过保存数据库执行的命令来记录数据库的状态。  

<img src="/img/redis/redis-aof.png"  alt="redis" align="center" />

AOF日志对数据库命令的保存顺序是，Redis 先执行命令，把数据写入内存，然后才记录日志。   

#### 为什么要后记录日志呢

1、后写，能够避免记录到错误的命令。因为是先执行命令，后写入日志，只有命令执行成功了，命令才能被写入到日志中。  

2、避免阻塞当前的写操作，是在命令执行后才记录日志，所以不会阻塞当前的写操作。  

#### AOF 的潜在风险

- 1、如果命令执行成功，写入日志的时候宕机了，命令没有写入到日志中，这时候就有丢失数据的风险了，因为这时候没有写入日志，服务断电之后，这部分数据就丢失了。  

这种场景在别的地方也很常见，比如基于 MQ 实现分布式事务，也会出现`业务处理成功 + 事务消息发送失败`这种场景，[RabbitMQ，RocketMQ，Kafka 事务性，消息丢失和消息重复发送的处理策略](https://www.cnblogs.com/ricklz/p/15747565.html#%E5%9F%BA%E4%BA%8E-mq-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1)  

- 2、AOF 的日志写入也是在主线程进行的，如果磁盘的压力很大，写入速度变慢了，会影响后续的操作。   

这两种情况可通过调整 AOF 文件的写入磁盘的时机来避免  

#### AOF 文件的写入和同步

AOF 文件持久化的功能分成三个步骤，文件追加(append),文件写入，文件同步(sync)。  

AOF 文件在写入磁盘之前是先写入到 aof_buf 缓冲区中，然后通过调用 flushAppendOnlyFile 将缓冲区中的内容保存到 AOF 文件中。  

写入的策略通过 appendfsync 来进行配置  

- always：将 aof_buf 缓冲区中的所有内容写入到 AOF 文件中，

- everysec: 每1秒钟将 aof_buf 缓冲区中的所有内容写入到 AOF 文件中，这个操作是在子线程中完成的     

- no：

#### AOF 文件重写机制

因为每次执行的命令都会被写入到 AOF 文件中，随着系统的运行，越来越多的文件会被写入到 AOF 文件中，这样 AOF 文件势必会变得很大，这种情况该如何去处理呢？   

为了解决这种情况，Redis 中引入了重写的机制  

什么是重写呢？  

因为 AOF 文件中记录的是每个命令的操作记录，举个🌰，比如当一个键值对被多条写命令反复修改时，AOF文件会记录相应的多条命令，那么重写机制，就是根据这个键值对当前的最新状态，为它生成对应的写入命令，保存成一行操作命令。这样就精简了 AOF 文件的大小。       

```
192.168.56.118:6379> set name "xiaoming"
OK
192.168.56.118:6379> get name
"xiaoming"
192.168.56.118:6379> set name "xiaozhang"
OK
192.168.56.118:6379> set name "xiaoli"
OK

# 重写后就是

192.168.56.118:6379> set name "xiaoli"
```

简单来讲就是多变一，就是把 AOF 中日志根据当前键值的状态，合并成一条操作命令。  

重写之后的文件会保存到新的 AOF 文件中，这时候旧的 AOF 文件和新的 AOF 文件中键值对的状态是一样的。然后新的 AOF 文件会替换掉旧的 AOF 文件，这样 重写操作一直在进行，AOF 文件就不至于变的过大。  

重写是后台进行的， AOF 的重写会放到子进程中进行的，使用子进程的优点：   

1、子进程处理 AOF 期间，不会影响 Redis 主线程对数据的处理；  

2、子进程拥有所在线程的数据副本，使用进程能够避免锁的使用，保证数据的安全。   

这里来看下，AOF 的处理流程  

AOF 重写也有一个缓冲区，当服务节接收到新的命令的是，如果在正在进行 AOF 重写，命令同样也会被发送到 AOF 缓冲区   

<img src="/img/redis/redis-aof-rewrite.png"  alt="redis" align="center" />

子进程执行 AOF 重写的过程,服务端进程主要处理以下内容   

1、接收并处理客户端发送的命令；  

2、将执行后的命令写入到 AOF 缓冲区；  

3、将执行后的命令也写入到 AOF 重写缓冲区；   

AOF 缓冲区和  AOF 重写缓冲区中的内容会被定期的同步到 AOF 文件和 AOF 重写文件中  

当子进程完成重写的时候，会给父进程发送一个信号，这时候父进程主要主要进行下面的两步操作：  

1、将 AOF 重写缓冲区中的内容全部写入到 AOF 重写文件中，这时候重写 AOF 文件保存的数据状态是和服务端数据库的状态一致的；  

2、将 AOF 重写文件替换旧的 AOF 文件；  

通过 AOF 的重写操作，新的 AOF 文件不断的替换旧的 AOF 文件，这样就能控制 AOF 文件的大小  
 
### RDB 持久化


### 参考

【Redis核心技术与实战】https://time.geekbang.org/column/intro/100056701    
【Redis设计与实现】https://book.douban.com/subject/25900156/  

                                 
