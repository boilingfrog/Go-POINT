<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [Redis 的高可用集群](#redis-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [几种常用的集群方案](#%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88)
  - [主从集群模式](#%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F)
    - [全量同步](#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5)
    - [增量同步](#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5)
  - [哨兵机制](#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6)
    - [什么是哨兵机制](#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6)
    - [如何保证选主的准确性](#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%80%89%E4%B8%BB%E7%9A%84%E5%87%86%E7%A1%AE%E6%80%A7)
    - [如何选主](#%E5%A6%82%E4%BD%95%E9%80%89%E4%B8%BB)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Redis 的高可用集群

### 前言

这里来了解一下，Redis 中常见的集群方案  

### 几种常用的集群方案

- 主从集群模式  

- 哨兵机制  

- 切片集群(分片集群)  

### 主从集群模式 

主从集群，主从库之间采用的是读写分离  

- 主库：所有的写操作都在读库发生，然后主库同步数据到从库，同时也可以进行读操作；    

- 从库：只负责读操作；

<img src="/img/redis/redis-read-write.png"  alt="redis" align="center" />

主库需要复制数据到从库，主从双方的数据库需要保存相同的数据，将这种情况称为"数据库状态一致"  

来看下如何同步之前先来了解下几个概念  

- 1、服务器的运行ID(run ID)：每个 Redis 服务器在运行期间都有自己的`run ID`，`run ID`在服务器启动的时候自动生成。  

从服务器会记录主服务器的`run ID`，这样如果发生断网重连，就能判断新连接上的主服务器是不是上次的那一个，这样来决定是否进行数据部分重传还是完整重新同步。  

- 2、复制偏移量 offset：主服务器和从服务器都会维护一个复制偏移量  

主服务器每次向从服务器中传递 N 个字节的时候，会将自己的复制偏移量加上 N。  

从服务器中收到主服务器的 N 个字节的数据，就会将自己额复制偏移量加上 N。  

通过主从服务器的偏移量对比可以很清楚的知道主从服务器的数据是否处于一致。  

如果不一致就需要进行增量同步了，具体参加下文的增量同步   

#### 全量同步

从服务器首次加入主服务器中发生的是全量同步 

如何进行第一次同步？  

<img src="/img/redis/redis-read-write-copy.png"  alt="redis" align="center" />

1、从服务器连接到主服务器，然后发送 psync 到主服务器，因为第一次复制，不知道主库`run ID`,所以`run ID`为？；    

2、主服务器接收到同步的响应，回复从服务器自己的`run ID`和复制进行进度 offset；  

3、主服务器开始同步所有数据到从库中，同步依赖 RDB 文件，主库会通过 bgsave 命令，生成 RDB 文件，然后将 RDB 文件传送到从库中；  

4、从库收到  RDB 文件,清除自己的数据，然后载入 RDB 文件；  

5、主库在同步的过程中不会被阻塞，仍然能接收到命令，但是新的命令是不能同步到从库的，所以主库会在内存中用专门的 `replication buffer`，记录 RDB 文件生成后收到的所有写操作，然后在 RDB 文件，同步完成之后，再将`replication buffer`中的命令发送到从库中，这样就保证了从库的数据同步。  

#### 增量同步

如果主从服务器之间发生了网络闪断，从从服务将会丢失一部分同步的命令。  

在旧版本，`Redis 2.8`之前，如果发生了网络闪断，就会进行一次全量复制。  

在 2.8 版本之后，引入了增量同步的技术，这里主要是用到了 `repl_backlog_buffer`  

Redis 主库接收到写操作的命令，首先会写入`replication buffer`(主要用于主从数据传输的数据缓冲)，同时也会把这些操作命令也写入`repl_backlog_buffer`这个缓冲区。  

<img src="/img/redis/redis-repl_backlog_buffer.png"  alt="redis" align="center" />

这里可能有点疑惑，已经有了`replication buffer`为什么还多余引入一个`repl_backlog_buffer`呢？  

- `repl_backlog_buffer`一个主库对应一个`repl_backlog_buffer`，也就是所有从库对应一个`repl_backlog_buffer`，从库自己记录自己的`slave_repl_offset`。  

- `replication buffer`用于主节点与各个从节点间，数据的批量交互。主节点为各个从节点分别创建一个缓冲区，由于各个从节点的处理能力差异，各个缓冲区数据可能不同。  

如何主从断开了，当然对应的`replication buffer`也就没有了。这时候就依赖`repl_backlog_buffer`进行数据的增量同步了。  

`repl_backlog_buffer`是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。  

这里借用[Redis核心技术与实战的一张图片](https://time.geekbang.org/column/intro/100056701)

<img src="/img/redis/repl_backlog_buffer.jpeg"  alt="redis" align="center" />

刚开始主服务器的 master_repl_offset 和从服务器 slave_repl_offset 的位置是一样的，在从库因为网络原因断连之后，随着主库写操作的进行，主从偏移量会出现偏移距离。  

当从服务器连上主服务器之后，从服务把自己当前的 slave_repl_offset 告诉主服务器，然后主服务器根据自己的 master_repl_offset 计算出和从服务器之间的差距，然后把两者之间相差的命令操作同步给从服务器。  

举个栗子  

比如这里从服务器1，刚刚由于网络原因断连了一会，然后又恢复了连接，这时候，可能缺失了一段时间的命令同步，`repl_backlog_buffer`的增量同步机制就登场了。  

`repl_backlog_buffer`会根据主服务器的`master_repl_offset`和从服务器`slave_repl_offset`，计算出两者命令之间的差距，之后把差距同步给`replication buffer`，然后发送到从服务器中。  

<img src="/img/redis/redis-repl_backlog.png"  alt="redis" align="center" />

`repl_backlog_buffer`中的缓冲空间要设置的大一点，如果从库读的过慢，因为是环形缓冲区，可能出现命令覆盖的情况，如果出现命令被覆盖了，从库的增量同步就无法进行了，这时候会进行一次全量的复制。  

缓冲空间的计算公式是：缓冲空间大小 = `主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小`。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 repl_backlog_size = 缓冲空间大小 * 2，这也就是 repl_backlog_size 的最终值。   

### 哨兵机制

对于主从集群模式，如果从库发生了故障，还有主库和其它的从库可以接收请求，但是如果主库挂了，就不能进行正常的数据写入，同时数据同步也不能正常的进行了，当然这种情况，我们需要想办法避免，于是就引入了下面的哨兵机制。  

#### 什么是哨兵机制

sentinel(哨兵机制)：是 Redis 中集群的高可用方式，哨兵节点是特殊的 Redis 服务，比提供读写，主要来监控 Redis 中的实例节点，如果监控服务的主服务器下线了，会从所属的从服务器中重新选出一个主服务器，代替原来的主服务器提供服务。  

<img src="/img/redis/redis-sentinel.png"  alt="redis" align="center" />

核心功能就是:监控，选主，通知。   

监控：哨兵机制，会周期性的给所有主服务器发出 PING 命令，检测它们是否仍然在线运行，如果在规定的时间内响应了 PING 通知则认为，仍在线运行；如果没有及时回复，则认为服务已经下线了，就会进行切换主库的动作。   

选主：当主库挂掉的时候，会从从库中按照既定的规则选出一个新的的主库，

通知：当一个主库被新选出来，会通知其他从库，进行连接，然后进行数据的复制。当客户端试图连接失效的主库时，集群也会向客户端返回新主库的地址，使得集群可以使用新的主库。  

#### 如何保证选主的准确性

哨兵会通过 PING 命令检测它和从库，主库之间的连接情况，如果发现响应超时就会认为给服务已经下线了。   

当然这会存在误判的情况，如果集群的网络压力比较大，网路堵塞，这时候会存在误判的情况。  

如果误判的节点是从节点，影响不会很大，拿掉一个从节点，对整体的服务，影响不大，还是会不间断的对外提供服务。

如果误判的节点是主节点，影响就很大了，主节点被标注下线了，就会触发后续的选主，数据同步，等一连串的动作，这一连串的动作很很消耗性能的。所以对于误判，应该去规避。  

如何减少误判呢？  

引入哨兵集群，一个哨兵节点可能会进行误判，引入多个少哨兵节点一起做决策，就能减少误判了。  

当有多个哨兵节点的时候，大多数哨兵节点认为主库下线了，主库才会真正的被标记为下线了，一般来讲当有 N 个哨兵实例时，最好要有`N/2 + 1`个实例判断主库下线了，才能最终判定主库的下线状态。当然这个数值在 Redis 中是可以配置的。  

#### 如何选主

先来看下选举主节点的规则  

1、过滤掉已经下线的服务器；  

2、过滤掉最近5秒钟没有回复过主节点的 INFO(用于观察服务器的角色) 命令的服务器，保证选中的服务器都是最近成功通过信的；  

3、过滤掉和下线主服务器连接超过`down-after-milliseconds*10`毫秒的从服务器，`down-after-milliseconds`是主服务器下线的时间，这一操作避免从服务器与主服务器过早的断开，影响到从库中数据同步，因为断开时间越久，从库里面的数据就越老旧过时。  

然后对这些服务器根据`slave-priority`优先级(这个优先级是手动设置的，比如希望那个从服务器优先变成主服务器，优先级就设置的高一点) 进行排序。  

如果几台从服务器优先级相同，然后根据复制偏移量从大到小进行排序，如果还有相同偏移量的从服务器，然后按照 runID 从小到大进行排序，直到选出一台从服务器。    







### 参考

【Redis核心技术与实战】https://time.geekbang.org/column/intro/100056701    
【Redis设计与实现】https://book.douban.com/subject/25900156/  