<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [Redis 中的缓冲区满了如何处理](#redis-%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BB%A1%E4%BA%86%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86)
  - [什么是缓冲区](#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA)
  - [输入缓冲区](#%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA)
    - [导致输入缓冲区内存溢出的场景](#%E5%AF%BC%E8%87%B4%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%9C%BA%E6%99%AF)
    - [查看输入缓冲区的占用情况](#%E6%9F%A5%E7%9C%8B%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5)
    - [如何避免输入缓冲区溢出](#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA)
  - [输出缓冲区](#%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA)
    - [如何应对输出缓冲区溢出](#%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA)
    - [输出缓冲区溢出的场景](#%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E7%9A%84%E5%9C%BA%E6%99%AF)
  - [主从集群中的缓冲区](#%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA)
    - [全量复制的缓冲区](#%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA)
    - [增量复制](#%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6)
  - [总结](#%E6%80%BB%E7%BB%93)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Redis 中的缓冲区满了如何处理

### 什么是缓冲区

Redis 是client-server架构，所有命令都需要通过客户端发送给服务端。所以，缓冲区在Redis中的一个主要应用场景，就是在客户端和服务器端之间进行通信时，用来暂存客户端发送的命令数据，或者是服务器端返回给客户端的数据结果。此外，缓冲区的另一个主要应用场景，是在主从节点间进行数据同步时，用来暂存主节点接收的写命令和数据。  

总结下缓冲区的作用就是  

1、存储，客户端发送带服务端和服务端发送到客户端的命令数据；  

2、主节点进行同步的时候，暂存同步的命令。   

### 输入缓冲区

#### 导致输入缓冲区内存溢出的场景

- 1、写入了 bigkey，比如一下子写入了多个百万级别的集合类型数据；  

- 2、服务器端处理请求的速度过慢，例如，Redis主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多。  

#### 查看输入缓冲区的占用情况

查看缓冲区的使用情况  

可以使用 `CLIENT LIST` 命令来查看缓冲区的占用情况  

````
127.0.0.1:6379> CLIENT LIST
id=5 addr=127.0.0.1:51981 fd=7 name= age=23 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client user=default
````

这里我们需要关注的有两个信息  

- 1、客户端和服务端的连接信息,如果有多个客户端，输出结果中的addr会显示不同客户端的IP和端口号；  

- 2、缓冲区相关的几个参数。  

主要看下，下面三个参数    

cmd：表示客户端最新执行的命令。这个例子中执行的是CLIENT命令。    

qbuf：表示输入缓冲区已经使用的大小。这个例子中的CLIENT命令已使用了26字节大小的缓冲区。  

qbuf-free：表示输入缓冲区尚未使用的大小。这个例子中的CLIENT命令还可以使用32742字节的缓冲区。qbuf和qbuf-free的总和就是，Redis服务器端当前为已连接的这个客户端分配的缓冲区总大小。这个例子中总共分配了 26 + 32742 = 32768字节，也就是32KB的缓冲区。  

如果 qbuf 数据很大，同时qbuf-free很小，就要引起注意了，因为这时候输入缓冲区已经占用了很多内存，而且没有什么空闲空间了，这时候如果有大量的命令写入，就有可能造成内存泄露了。  

#### 如何避免输入缓冲区溢出

- 1、调大缓冲区的大小；  

不过 Redis 中缓冲区的上线阀值是固定的 1GB。  

1、这个大小已经足够处理大部分的客户端请求了；  

2、如果过大，可能导致因为缓冲区的命令的过大的资源占用，导致崩溃。  

- 2、优化命令的发送和处理速度。  

避免客户端写入bigkey，以及避免Redis主线程阻塞。  

### 输出缓冲区

#### 如何应对输出缓冲区溢出

Redis 的输出缓冲区暂存的是 Redis 主线程要返回给客户端的数据。一般来说，主线程返回给客户端的数据，既有简单且大小固定的OK响应（例如，执行SET命令）或报错信息，也有大小不固定的、包含具体数据的执行结果（例如，执行HGET命令）。  

输出缓冲区的内容主要有两部分：  

1、一个大小为16KB的固定缓冲空间，用来暂存OK响应和出错信息；  

2、一个可以动态增加的缓冲空间，用来暂存大小可变的响应结果。  

#### 输出缓冲区溢出的场景

输出缓冲区溢出的情况有下面几种  

1、服务器端返回 bigkey 的大量结果；  

2、执行了MONITOR命令；  

3、缓冲区大小设置得不合理。  

bigkey 就很好理解，本身就会占用很大的内存，当放入到输出缓冲区的时候，就会影响到缓冲区。  

MONITOR命令是用来监测Redis执行的。执行这个命令之后，就会持续输出监测到的各个命令操作。  

```
127.0.0.1:6379> MONITOR
OK
1648985387.006454 [0 127.0.0.1:51982] "COMMAND"
1648985391.556787 [0 127.0.0.1:51982] "get" "testt"
1648985393.815648 [0 127.0.0.1:51982] "get" "testt"
1648985394.490677 [0 127.0.0.1:51982] "get" "testt"
1648985395.051021 [0 127.0.0.1:51982] "get" "testt"
1648985405.826455 [0 127.0.0.1:51982] "set" "t" "123"
```

MONITOR 的输出结果会持续占用输出缓冲区，并越占越多，最后的结果就是发生溢出。所以线上建议持续使用 MONITOR 命令。  

和输入缓冲区不同，输出缓冲区的大小可以通过client-output-buffer-limit配置项，来设置缓冲区的大小。具体设置的内容包括两方面：  

- 设置缓冲区大小的上限阈值；  

- 设置输出缓冲区持续写入数据的数量上限阈值，和持续写入数据的时间的上限阈值。  

普通客户端设置缓冲区大小  

```
client-output-buffer-limit normal 0 0 0
```

normal 表示当前设置的是普通客户端，第1个0设置的是缓冲区大小限制，第2个0和第3个0分别表示缓冲区持续写入量限制和持续写入时间限制。   

普通客户端，每次发送完一个请求，需要等待结果的返回，然后发送下一个请求，这种方式就是阻塞式发送。这种情况下，除非是读取体量很大的 bigkey，服务端的输出缓冲是不会进行阻塞的。  

所以，我们通常把普通客户端的缓冲区大小限制，以及持续写入量限制、持续写入时间限制都设置为0，也就是不做限制。  

订阅的客户端  

对于订阅客户端来说，一旦订阅的Redis频道有消息了，服务器端都会通过输出缓冲区把消息发给客户端。所以，订阅客户端和服务器间的消息发送方式，不属于阻塞式发送。不过，如果频道消息较多的话，也会占用较多的输出缓冲区空间。  

```
client-output-buffer-limit pubsub 8mb 2mb 60
```

其中，pubsub参数表示当前是对订阅客户端进行设置；8mb表示输出缓冲区的大小上限为8MB，一旦实际占用的缓冲区大小要超过8MB，服务器端就会直接关闭客户端的连接；2mb和60表示，如果连续60秒内对输出缓冲区的写入量超过2MB的话，服务器端也会关闭客户端连接。  

### 主从集群中的缓冲区 

主从集群中的复制分成了两种 增量复制和全量复制。这两种复制，数据都是先发送的复制缓冲区，然后同步到从节点中。  

#### 全量复制的缓冲区  

<img src="/img/redis/redis-buffer.webp"  alt="redis" align="center" />    

如果在全量复制时，从节点接收和加载RDB较慢，同时主节点接收到了大量的写命令，写命令在复制缓冲区中就会越积越多，最终导致溢出。  

**如何避免**  

- 1、控制主节点保存的数据量的大小；  

通常，会把主节点的数据量控制在2~4GB，这样可以让全量同步执行得更快些，避免复制缓冲区累积过多命令。  

- 2、设置合理的复制缓冲区大小。  

```
config set client-output-buffer-limit slave 512mb 128mb 60
```

其中，slave参数表明该配置项是针对复制缓冲区的。512mb代表将缓冲区大小的上限设置为512MB；128mb和60代表的设置是，如果连续60秒内的写入量超过128MB的话，也会触发缓冲区溢出。  

我们再继续看看这个设置对我们有啥用。假设一条写命令数据是1KB，那么，复制缓冲区可以累积512K条（512MB/1KB = 512K）写命令。同时，主节点在全量复制期间，可以承受的写命令速率上限是2000条/s（128MB/1KB/60 约等于2000）。  

这样一来，我们就得到了一种方法：在实际应用中设置复制缓冲区的大小时，可以根据写命令数据的大小和应用的实际负载情况（也就是写命令速率），来粗略估计缓冲区中会累积的写命令数据量；然后，再和所设置的复制缓冲区大小进行比较，判断设置的缓冲区大小是否足够支撑累积的写命令数据量。  

主节点上复制缓冲区的内存开销，是每个从节点客户端输出缓冲区占用内存的总和。如果集群中的从节点数非常多的话，主节点的内存开销就会非常大。所以我们也需要控制和主节点连接的从节点的数量。  

#### 增量复制

增量复制时使用的缓冲区，这个缓冲区称为复制积压缓冲区。  

复制积压缓冲区是一个大小有限的环形缓冲区。当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据。如果从节点还没有同步这些旧命令数据，就会造成主从节点间重新开始执行全量复制。  

为了应对复制积压缓冲区的溢出问题，我们可以调整复制积压缓冲区的大小，也就是设置repl_backlog_size这个参数的值。可参见[量同步](https://www.cnblogs.com/ricklz/p/15916014.html#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5)  

### 总结

缓冲区可分成两类，输出缓冲区和输入缓冲区  

- 缓冲区溢出导致网络连接关闭：普通客户端、订阅客户端，以及从节点客户端，它们使用的缓冲区，本质上都是Redis客户端和服务器端之间，或是主从节点之间为了传输命令数据而维护的。这些缓冲区一旦发生溢出，处理机制都是直接把客户端和服务器端的连接，或是主从节点间的连接关闭。网络连接关闭造成的直接影响，就是业务程序无法读写Redis，或者是主从节点全量同步失败，需要重新执行。  

- 缓冲区溢出导致命令数据丢失：主节点上的复制积压缓冲区属于环形缓冲区，一旦发生溢出，新写入的命令数据就会覆盖旧的命令数据，导致旧命令数据的丢失，进而导致主从节点重新进行全量复制。  

缓冲区的溢出主要是三个方面  

1、命令数据发送过快过大；  

2、命令数据处理较慢；  

3、缓冲区空间过小。  

针对上面的几个溢出的场景，有下面几种应对策略  

- 针对命令数据发送过快过大的问题，对于普通客户端来说可以避免bigkey，而对于复制缓冲区来说，就是避免过大的RDB文件。

- 针对命令数据处理较慢的问题，解决方案就是减少Redis主线程上的阻塞操作，例如使用异步的删除操作。

- 针对缓冲区空间过小的问题，解决方案就是使用client-output-buffer-limit配置项设置合理的输出缓冲区、复制缓冲区和复制积压缓冲区大小。当然，我们不要忘了，输入缓冲区的大小默认是固定的，我们无法通过配置来修改它，除非直接去修改Redis源码。

### 参考

【Redis核心技术与实战】https://time.geekbang.org/column/intro/100056701    
【Redis设计与实现】https://book.douban.com/subject/25900156/  