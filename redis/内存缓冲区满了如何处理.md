<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [Redis 中的缓冲区满了如何处理](#redis-%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BB%A1%E4%BA%86%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86)
  - [什么是缓冲区](#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA)
  - [导致内存溢出的场景](#%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%9C%BA%E6%99%AF)
  - [查看缓冲区的占用情况](#%E6%9F%A5%E7%9C%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5)
  - [如何避免缓冲区溢出](#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA)
  - [如何应对内存缓冲区的溢出](#%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%86%85%E5%AD%98%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%BA%A2%E5%87%BA)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Redis 中的缓冲区满了如何处理

### 什么是缓冲区

Redis 是client-server架构，所有命令都需要通过客户端发送给服务端。所以，缓冲区在Redis中的一个主要应用场景，就是在客户端和服务器端之间进行通信时，用来暂存客户端发送的命令数据，或者是服务器端返回给客户端的数据结果。此外，缓冲区的另一个主要应用场景，是在主从节点间进行数据同步时，用来暂存主节点接收的写命令和数据。  

总结下缓冲区的作用就是  

1、存储，客户端发送带服务端和服务端发送到客户端的命令数据；  

2、主节点进行同步的时候，暂存同步的命令。   

### 导致内存溢出的场景

- 1、写入了bigkey，比如一下子写入了多个百万级别的集合类型数据；  

- 2、服务器端处理请求的速度过慢，例如，Redis主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多。  

### 查看输入缓冲区的占用情况

查看缓冲区的使用情况  

可以使用 `CLIENT LIST` 命令来查看缓冲区的占用情况  

````
127.0.0.1:6379> CLIENT LIST
id=5 addr=127.0.0.1:51981 fd=7 name= age=23 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client user=default
````

这里我们需要关注的有两个信息  

- 1、客户端和服务端的连接信息,如果有多个客户端，输出结果中的addr会显示不同客户端的IP和端口号；  

- 2、缓冲区相关的几个参数。  

主要看下，下面三个参数    

cmd：表示客户端最新执行的命令。这个例子中执行的是CLIENT命令。    

qbuf：表示输入缓冲区已经使用的大小。这个例子中的CLIENT命令已使用了26字节大小的缓冲区。  

qbuf-free：表示输入缓冲区尚未使用的大小。这个例子中的CLIENT命令还可以使用32742字节的缓冲区。qbuf和qbuf-free的总和就是，Redis服务器端当前为已连接的这个客户端分配的缓冲区总大小。这个例子中总共分配了 26 + 32742 = 32768字节，也就是32KB的缓冲区。  

如果 qbuf 数据很大，同时qbuf-free很小，就要引起注意了，因为这时候输入缓冲区已经占用了很多内存，而且没有什么空闲空间了，这时候如果有大量的命令写入，就有可能造成内存泄露了。  

### 如何避免缓冲区溢出

- 1、调大缓冲区的大小；  

不过 Redis 中缓冲区的上线阀值是固定的 1GB。  

1、这个大小已经足够处理大部分的客户端请求了；  

2、如果过大，可能导致因为缓冲区的命令的过大的资源占用，导致崩溃。  

- 2、优化命令的发送和处理速度。  

避免客户端写入bigkey，以及避免Redis主线程阻塞。  

### 如何应对输出缓冲区溢出

Redis 的输出缓冲区暂存的是 Redis 主线程要返回给客户端的数据。一般来说，主线程返回给客户端的数据，既有简单且大小固定的OK响应（例如，执行SET命令）或报错信息，也有大小不固定的、包含具体数据的执行结果（例如，执行HGET命令）。  

输出缓冲区的内容主要有两部分：  

1、一个大小为16KB的固定缓冲空间，用来暂存OK响应和出错信息；  

2、一个可以动态增加的缓冲空间，用来暂存大小可变的响应结果。  

输出缓冲区溢出的情况有下面几种  

1、服务器端返回 bigkey 的大量结果；  

2、执行了MONITOR命令；  

3、缓冲区大小设置得不合理。  

bigkey 就很好理解，本身就会占用很大的内存，当放入到输出缓冲区的时候，就会影响到缓冲区。  

MONITOR命令是用来监测Redis执行的。执行这个命令之后，就会持续输出监测到的各个命令操作。  

```
127.0.0.1:6379> MONITOR
OK
1648985387.006454 [0 127.0.0.1:51982] "COMMAND"
1648985391.556787 [0 127.0.0.1:51982] "get" "testt"
1648985393.815648 [0 127.0.0.1:51982] "get" "testt"
1648985394.490677 [0 127.0.0.1:51982] "get" "testt"
1648985395.051021 [0 127.0.0.1:51982] "get" "testt"
1648985405.826455 [0 127.0.0.1:51982] "set" "t" "123"
```

MONITOR 的输出结果会持续占用输出缓冲区，并越占越多，最后的结果就是发生溢出。所以线上建议持续使用 MONITOR 命令。  







 
### 参考

【Redis核心技术与实战】https://time.geekbang.org/column/intro/100056701    
【Redis设计与实现】https://book.douban.com/subject/25900156/  