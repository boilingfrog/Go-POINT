## go笔试题目

1、go中gc触发的场景？  

2、TCP 和 UDP 有什么区别,适用场景？  

3、go中内存泄露的场景？  

4、go中的逃逸分析是什么？怎么避免内存逃逸？     

5、select和range的区别？  

6、死锁产生的条件？  

7、mysql中索引的创建原则？  

8、mysql中查询优化，有什么需要注意的点？ 

9、redis的数据类型？  

10、redis中key过期如何自动删除？  

11、为什么redis能够实现分布式锁？  

12、服务发现怎么实现的？  

13、mq中如何防止消息重复？  

14、数据库读写分离，会有同步的时间，如何避免插入之后的马上查询，从库同步不及时的问题？  

15、下面题目输出什么？为什么？  

```go
func main() {
	for i := 0; i < 10; i++ {
		go func() {
			fmt.Println(i)
		}()
	}
	time.Sleep(time.Second * 3)
}
```

16、下面代码有异常吗?如何定位？  

```go
func main() {
	var (
		err error
		eg  errgroup.Group
	)

	eg.Go(func() error {
		err = test1()
		return err
	})

	eg.Go(func() error {
		err = test2()
		return err
	})

	err = eg.Wait()

	fmt.Println(err)
}
```



17、下面执行的输出？

```go
func main() {
	ch := make(chan int, 1)
	go func() {
		ch <- 1
	}()

	go func() {
		ch <- 2
	}()

	close(ch)

	select {
	case item := <-ch:
		fmt.Println(item)
	}
}
```

18、下面程序的输出，为什么？  

```go
func main() {
	fmt.Println(1)

	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err)
		}
	}()

	go func() {
		fmt.Println(2)
		panic("3")
	}()
	time.Sleep(time.Second)
}
```

19、下面程序的输出？  

```go
func main() {
	s1 := []int{2, 3, 6, 2, 4, 5, 6, 7}
	s2 := s1[6:7]
	fmt.Println("原切片", s1)
	fmt.Println("新切片", s2)

	s2 = append(s2, 100)
	fmt.Println("append之后的新切片", s2)
	fmt.Println("老切片", s1)

	s2 = append(s2, 888)
	fmt.Println("append之后的新切片", s2)
	fmt.Println("老切片", s1)
}
```

20、手写m个sender和n个receiver的程序，sender产生数据，receiver消费数据，使用channel进行传递，保证程序能够完美退出。  
