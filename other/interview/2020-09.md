<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [准备面试](#%E5%87%86%E5%A4%87%E9%9D%A2%E8%AF%95)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [准备](#%E5%87%86%E5%A4%87)
    - [go中的gc](#go%E4%B8%AD%E7%9A%84gc)
    - [redis](#redis)
    - [Goroutine和线程的区别?](#goroutine%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [滑动窗口，了解下](#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BA%86%E8%A7%A3%E4%B8%8B)
    - [公钥私钥的交互流程](#%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5%E7%9A%84%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B)
    - [go中逃逸分析](#go%E4%B8%AD%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 准备面试

### 前言

这是一次被迫跳槽，可能这就是生活。 

### 准备

**go的并发机制和csp并发模型**  

使用的以通信的方式共享内存。  

Goroutine是用户态的线程。  

go中有三个对象P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）.  

**go中常见的并发模型**  

通过channel实现并发控制  

使用`WaitGroup`  

`Context`  

它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。  

context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。  

````go
// A Context carries a deadline, cancelation signal, and request-scoped values
// across API boundaries. Its methods are safe for simultaneous use by multiple
// goroutines.
type Context interface {
    // Done returns a channel that is closed when this `Context` is canceled
    // or times out.
    // Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号
    Done() <-chan struct{}


    // Err indicates why this Context was canceled, after the Done channel
    // is closed.
    // Err() 在Done() 之后，返回context 取消的原因。
    Err() error

    // Deadline returns the time when this Context will be canceled, if any.
    // Deadline() 设置该context cancel的时间点
    Deadline() (deadline time.Time, ok bool)

    // Value returns the value associated with key or nil if none.
    // Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。
    Value(key interface{}) interface{}
}
````

Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。

一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。  
 
典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。  



**silce**

具体查下[https://www.cnblogs.com/ricklz/p/11898180.html]


**协程，线程，进程**  

- 进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。  

- 线程  

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。  

- 协程

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快  

**内存屏障**  


每个协程初始化2k的栈空间


**Data Race**   

#### go中的gc
   
三色标记  

三色标记，通过字面意思我们就可以知道它由3种颜色组成：  

黑色 Black：表示对象是可达的，即使用中的对象，黑色是已经被扫描的对象。  

灰色 Gary：表示被黑色对象直接引用的对象，但还没对它进行扫描。   

白色 White：白色是对象的初始颜色，如果扫描完成后，对象依然还是白色的，说明此对象是垃圾对象。  

三色标记规则：黑色不能指向白色对象。即黑色可以指向灰色，灰色可以指向白色。  

屏障技术  

强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象;  
弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径;  



#### redis


#### Goroutine和线程的区别?


#### 滑动窗口，了解下


#### 公钥私钥的交互流程

#### go中逃逸分析


首先区分下堆和栈的区别：  

栈是由操作系统自己分配释放的，用于存储函数的参数值，局部变量等。  

堆是由开发人员分配和释放的，如果开发人员未释放，程序结束os自动回收，分配方式类似链表  

**两者的区别**  

1、管理方式不同。栈系统自动分配，堆由程序员控制和释放，容易产生内存泄露。  

2、空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员申请的堆大小为虚拟内存的大小，进程栈的大小64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB。  

3、生长的方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下。内存由高到到低。   

4、分配方式不同。堆是动态分配的，没有静态分配的堆。栈的分配有两种方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。  

5、分配效率的不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。  

6、存放的内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。  

Go中逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就发生逃逸。  

简单来说，编译器会根据变量是否被外部引用来决定是否逃逸：

1、如果函数外部没有引用，则优先放到栈中；  

2、如果函数外部存在引用，则必定放到堆中;  








