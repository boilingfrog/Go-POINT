## 准备面试

### 前言

这是一次被迫跳槽，可能这就是生活。 

### 准备

**go的并发机制和csp并发模型**  

使用的以通信的方式共享内存。  

Goroutine是用户态的线程。  

go中有三个对象P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）.  

**go中常见的并发模型**  

通过channel实现并发控制  

使用`WaitGroup`  

`Context`  

它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。  

context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。  

````go
// A Context carries a deadline, cancelation signal, and request-scoped values
// across API boundaries. Its methods are safe for simultaneous use by multiple
// goroutines.
type Context interface {
    // Done returns a channel that is closed when this `Context` is canceled
    // or times out.
    // Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号
    Done() <-chan struct{}


    // Err indicates why this Context was canceled, after the Done channel
    // is closed.
    // Err() 在Done() 之后，返回context 取消的原因。
    Err() error

    // Deadline returns the time when this Context will be canceled, if any.
    // Deadline() 设置该context cancel的时间点
    Deadline() (deadline time.Time, ok bool)

    // Value returns the value associated with key or nil if none.
    // Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。
    Value(key interface{}) interface{}
}
````

Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。

一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。  
 
典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。  



**silce**

具体查下[https://www.cnblogs.com/ricklz/p/11898180.html]


**协程，线程，进程**  

- 进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。  

- 线程  

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。  

- 协程

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快  

**内存屏障**  


每个协程初始化2k的栈空间


**Data Race**   

#### go中的gc
   
三色标记  

三色标记，通过字面意思我们就可以知道它由3种颜色组成：  

黑色 Black：表示对象是可达的，即使用中的对象，黑色是已经被扫描的对象。  

灰色 Gary：表示被黑色对象直接引用的对象，但还没对它进行扫描。   

白色 White：白色是对象的初始颜色，如果扫描完成后，对象依然还是白色的，说明此对象是垃圾对象。  

三色标记规则：黑色不能指向白色对象。即黑色可以指向灰色，灰色可以指向白色。  

屏障技术  

强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象;  
弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径;  



#### redis