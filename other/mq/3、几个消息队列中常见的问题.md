<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [消息队列常见问题处理](#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86)
  - [分布式事务](#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1)
    - [什么是分布式事务](#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1)
    - [常见的分布式事务解决方案](#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
    - [基于 MQ 实现的分布式事务](#%E5%9F%BA%E4%BA%8E-mq-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1)
      - [本地消息表-最终一致性](#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7)
      - [MQ事务-最终一致性](#mq%E4%BA%8B%E5%8A%A1-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7)
    - [RocketMQ中如何处理事务](#rocketmq%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1)
    - [Kafka中如何处理事务](#kafka%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1)
    - [RabbitMQ中的事务](#rabbitmq%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1)
  - [消息防丢失](#%E6%B6%88%E6%81%AF%E9%98%B2%E4%B8%A2%E5%A4%B1)
    - [生产阶段防止消息丢失](#%E7%94%9F%E4%BA%A7%E9%98%B6%E6%AE%B5%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1)
      - [RabbitMQ 中的防丢失措施](#rabbitmq-%E4%B8%AD%E7%9A%84%E9%98%B2%E4%B8%A2%E5%A4%B1%E6%8E%AA%E6%96%BD)
      - [Kafka 中的防丢失措施](#kafka-%E4%B8%AD%E7%9A%84%E9%98%B2%E4%B8%A2%E5%A4%B1%E6%8E%AA%E6%96%BD)
      - [RocketMQ 中的防丢失措施](#rocketmq-%E4%B8%AD%E7%9A%84%E9%98%B2%E4%B8%A2%E5%A4%B1%E6%8E%AA%E6%96%BD)
    - [存储阶段](#%E5%AD%98%E5%82%A8%E9%98%B6%E6%AE%B5)
      - [RabbitMQ 中的防丢失措施](#rabbitmq-%E4%B8%AD%E7%9A%84%E9%98%B2%E4%B8%A2%E5%A4%B1%E6%8E%AA%E6%96%BD-1)
      - [Kafka 中的防丢失措施](#kafka-%E4%B8%AD%E7%9A%84%E9%98%B2%E4%B8%A2%E5%A4%B1%E6%8E%AA%E6%96%BD-1)
      - [rocketmq 中的防丢失措施](#rocketmq-%E4%B8%AD%E7%9A%84%E9%98%B2%E4%B8%A2%E5%A4%B1%E6%8E%AA%E6%96%BD)
  - [消息重复发送](#%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81)
  - [处理消息的挤压](#%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%9A%84%E6%8C%A4%E5%8E%8B)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 消息队列常见问题处理

### 分布式事务

#### 什么是分布式事务

我们的服务器从单机发展到拥有多台机器的分布式系统，各个系统之前需要借助于网络进行通信，原有单机中相对可靠的方法调用以及进程间通信方式已经没有办法使用，同时网络环境也是不稳定的，造成了我们多个机器之间的数据同步问题，这就是典型的分布式事务问题。  

在分布式事务中事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。分布式事务就是要保证不同节点之间的数据一致性。    

#### 常见的分布式事务解决方案

1、2PC(二阶段提交)方案 - 强一致性  

2、3PC(三阶段提交)方案  

3、TCC （Try-Confirm-Cancel）事务 - 最终一致性   

4、Saga事务 - 最终一致性

5、本地消息表 - 最终一致性  

6、MQ事务 - 最终一致性

这里重点关注下使用消息队列实现分布式的一致性，上面几种的分布式设计方案的具体细节可参见文章最后的引用链接      

#### 基于 MQ 实现的分布式事务 

##### 本地消息表-最终一致性   

消息的生产方，除了维护自己的业务逻辑之外，同时需要维护一个消息表。这个消息表里面记录的就是需要同步到别的服务的信息，当然这个消息表，每个消息都有一个状态值，来标识这个消息有没有被成功处理。   

发送放的业务逻辑以及消息表中数据的插入将在一个事务中完成，这样避免了`业务处理成功 + 事务消息发送失败`，或`业务处理失败 + 事务消息发送成功`，这个问题。    

<img src="/img/mq-local-shiwu.png"  alt="mq" align="center" />

举个栗子：   

我们假定目前有两个服务，订单服务，购物车服务，用户在购物车中对几个商品进行合并下单，之后需要情况购物车中刚刚已经下单的商品信息。      

**1、消息的生产方也就是订单服务，完成了自己的逻辑(对商品进行下单操作)然后把这个消息通过 mq 发送到需要进行数据同步的其他服务中，也就是我们栗子中的购物车服务。**

**2、其他服务(购物车服务)会监听这个队列；**  

1、如果收到这个消息，并且数据同步执行成功了，当然这也是一个本地事务，就通过 mq 回复消息的生产方(订单服务)消息已经处理了，然后生产方就能标识本次事务已经结束。如果是一个业务上的错误,就回复消息的生产方，需要进行数据回滚了。   

2、很久没收到这个消息，这种情况是不会发生的，消息的发送方会有一个定时的任务，会定时重试发送消息表中还没有处理的消息；

**3、消息的生产方(订单服务)如果收到消息回执；**  

1、成功的话就修改本次消息已经处理完，也就是本次分布式事务的同步已经完成；   

2、如果消息的结果是执行失败，同时在本地回滚本次事务，标识消息已经处理完成；   

3、如果消息丢失，也就是回执消息没有收到，这种情况也不太会发生，消息的发送方(订单服务)会有一个定时的任务，定时重试发送消息表中还没有处理的消息，下游的服务需要做幂等，可能会收到多次重复的消息，如果一个回复消息生产方中的某个回执信息丢失了，后面持续收到生产方的 mq 消息，然后再次回复消息的生产方回执信息，这样总能保证发送者能成功收到回执，消息的生产方在接收回执消息的时候也要做到幂等性。         

这里有两个很重要的操作：  

1、服务器处理消息需要是幂等的，消息的生产方和接收方都需要做到幂等性；  

2、发送放需要添加一个定时器来遍历重推未处理的消息，避免消息丢失，造成的事务执行断裂。  

该方案的优缺点   

优点：   

1、在设计层面上实现了消息数据的可靠性，不依赖消息中间件，弱化了对 mq 特性的依赖。  

2、简单，易于实现。  

缺点：   

主要是需要和业务数据绑定到一起，耦合性比较高，使用相同的数据库，会占用业务数据库的一些资源。     

##### MQ事务-最终一致性   

#### RocketMQ中如何处理事务

RocketMQ 中的事务，它解决的问题是，确保执行本地事务和发消息这两个操作，要么都成功，要么都失败。并且，RocketMQ 增加了一个事务反查的机制，来尽量提高事务执行的成功率和数据一致性。   

<img src="/img/mq-rocketmq-shiwu.png"  alt="mq" align="center" />

主要是两个方面，正常的事务提交和事务消息补偿   

正常的事务提交  

1、发送消息（half消息），这个 half 消息和普通消息的区别，在事务提交 之前，对于消费者来说，这个消息是不可见的。   

2、`MQ SERVER`写入信息，并且返回响应的结果；   

3、根据`MQ SERVER`响应的结果，决定是否执行本地事务,如果`MQ SERVER`写入信息成功执行本地事务，否则不执行；   

4、根据本地事务执行的状态，决定是否对事务进行 Commit 或者 Rollback。`MQ SERVER`收到 Commit，之后就会投递该消息到下游的订阅服务，下游的订阅服务就能进行数据同步，如果是 Rollback 则该消息就会被丢失；     

如果`MQ SERVER`没有收到 Commit 或者 Rollback 的消息，这种情况就需要进行补偿流程了    

补偿流程   

1、`MQ SERVER`如果没有收到来自消息发送方的 Commit 或者 Rollback 消息，就会向消息发送端也就是我们的服务器发起一次查询，查询当前消息的状态；  

2、消息发送方收到对应的查询请求，查询事务的状态，然后把状态重新推送给`MQ SERVER`，`MQ SERVER`就能之后后续的流程了。    

相比于本地消息表来处理分布式事务，MQ 事务是把原本应该在本地消息表中处理的逻辑放到了 MQ 中来完成。   

#### Kafka中如何处理事务

Kafka 中的事务解决问题，确保在一个事务中发送的多条信息，要么都成功，要么都失败。也就是保证对多个分区写入操作的原子性。   

通过配合 Kafka 的幂等机制来实现 Kafka 的 `Exactly Once`，满足了`读取-处理-写入`这种模式的应用程序。当然 Kafka 中的事务主要也是来处理这种模式的。          

什么是`读取-处理-写入`模式呢？   

栗如：在流计算中，用 Kafka 作为数据源，并且将计算结果保存到 Kafka 这种场景下，数据从 Kafka 的某个主题中消费，在计算集群中计算，再把计算结果保存在 Kafka 的其他主题中。这个过程中，要保证每条消息只被处理一次，这样才能保证最终结果的成功。Kafka 事务的原子性就保证了，读取和写入的原子性，两者要不一起成功，要不就一起失败回滚。     

这里来分析下 Kafka 的事务是如何实现的   

它的实现原理和 RocketMQ 的事务是差不多的，都是基于两阶段提交来实现的，在实现上可能更麻烦   

先来介绍下事务协调者，为了解决分布式事务问题，Kafka 引入了事务协调者这个角色，负责在服务端协调整个事务。这个协调者并不是一个独立的进程，而是 Broker 进程的一部分，协调者和分区一样通过选举来保证自身的可用性。   

Kafka 集群中也有一个特殊的用于记录事务日志的主题，里面记录的都是事务的日志。同时会有多个协调者的存在，每个协调者负责管理和使用事务日志中的几个分区。这样能够并行的执行事务，提高性能。    

下面看下具体的流程   

- 1、首先在开启事务的时候，生产者会给协调者发送一个开启事务的请求，协调者在事务日志中记录下事务ID;    

- 2、然后生产者开始发送事务消息给协调者，不过需要先发送消息告知协调者在哪个主题和分区，之后就正常的发送事务消息，这些事务消息不像 RocketMQ 会保存在特殊的队列中，Kafka 未提交的事务消息和普通的消息一样，只是在消费的时候依赖客户端进行过滤。   

- 3、消息发送完成，生产者根据自己的执行的状态对协调者进行事务的提交或者回滚；   

事务的提交   

1、协调者设置事务的状态为PrepareCommit，写入到事务日志中；   

2、协调者在每个分区中写入事务结束的标识，然后客户端就能把之前过滤的未提交的事务消息放行给消费端进行消费了；   

事务的回滚   

1、协调者设置事务的状态为PrepareAbort，写入到事务日志中；   

2、协调者在每个分区中写入事务回滚的标识，然后之前未提交的事务消息就能被丢弃了；  

这里引用一下【消息队列高手课中的图片】      

<img src="/img/kafka-shiwu.png"  alt="mq" align="center" />

#### RabbitMQ中的事务

RabbitMQ 中事务解决的问题是确保生产者的消息到达`MQ SERVER`，这和其他 MQ 事务还是有点差别的，这里也不展开讨论了。    

### 消息防丢失

先来分析下一条消息在 MQ 中流转所经历的阶段。   

<img src="/img/mq-message.png"  alt="mq" align="center" />

**生产阶段**：生产者产生消息，通过网络发送到 Broker 端。   

**存储阶段**：Broker 拿到消息，需要进行落盘，如果是集群版的 MQ 还需要同步数据到其他节点。   

**消费阶段**：消费者在 Broker 端拉数据，通过网络传输到达消费者端。   

#### 生产阶段防止消息丢失

发生网络丢包、网络故障等这些会导致消息的丢失   

##### RabbitMQ 中的防丢失措施     

- 1、对于可以感知的错误，我们捕获错误，然后重新投递；     

- 2、通过 RabbitMQ 中的事务解决，RabbitMQ 中的事务解决的就是生产阶段消息丢失的问题；     

在生产者发送消息之前，通过`channel.txSelect`开启一个事务，接着发送消息， 如果消息投递 server 失败，进行事务回滚`channel.txRollback`，然后重新发送， 如果 server 收到消息，就提交事务`channel.txCommit`     

不过使用事务性能不好，这是同步操作，一条消息发送之后会使发送端阻塞，以等待`RabbitMQ Server`的回应，之后才能继续发送下一条消息，生产者生产消息的吞吐量和性能都会大大降低。     

- 3、使用发送确认机制。    

使用确认机制，生产者将信道设置成 confirm 确认模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，RabbitMQ 就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一 deliveryTag 和 multiple 参数），这就使得生产者知晓消息已经正确到达了目的地了。  

multiple 为 true 表示的是批量的消息确认，为 true 的时候，表示小于等于返回的 deliveryTag 的消息 id 都已经确认了，为 false 表示的是消息 id 为返回的 deliveryTag 的消息，已经确认了。   

<img src="/img/mq-rabbitmq-producer-lose.png"  alt="mq" align="center" />

确认机制有三种类型   

1、同步确认  

2、批量确认  

3、异步确认   

同步模式的效率很低，因为每一条消息度都需要等待确认好之后，才能处理下一条；  

批量确认模式相比同步模式效率是很高，不过有个致命的缺陷，一旦回复确认失败，当前确认批次的消息会全部重新发送，导致消息重复发送；   

异步模式就是个很好的选择了，不会有同步模式的阻塞问题，同时效率也很高，是个不错的选择。    

##### Kafka 中的防丢失措施

Kafaka 中引入了一个 broker。 broker 会对生产者和消费者进行消息的确认，生产者发送消息到 broker，如果没有收到 broker 的确认就可以选择继续发送。   

只要 Producer 收到了 Broker 的确认响应，就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户。  

只要正确处理 Broker 的确认响应，就可以避免消息的丢失。   

##### RocketMQ 中的防丢失措施

- 使用 SYNC 的发送消息方式，等待 broker 处理结果  

RocketMQ 提供了3种发送消息方式，分别是：  

同步发送：Producer 向 broker 发送消息，阻塞当前线程等待 broker 响应 发送结果。  

异步发送：Producer 首先构建一个向 broker 发送消息的任务，把该任务提交给线程池，等执行完该任务时，回调用户自定义的回调函数，执行处理结果。  

Oneway发送：Oneway 方式只负责发送请求，不等待应答，Producer 只负责把请求发出去，而不处理响应结果。  

- 使用事务，RocketMQ 中的事务，它解决的问题是，确保执行本地事务和发消息这两个操作，要么都成功，要么都失败。   

#### 存储阶段

在存储阶段正常情况下，只要 Broker 在正常运行，就不会出现丢失消息的问题，但是如果 Broker 出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的。   

##### RabbitMQ 中的防丢失措施     

防止在存储阶段消息额丢失，可以做持久化，防止异常情况(重启，关闭，宕机)。。。   

RabbitMQ 持久化中有三部分：   

- 交换器的持久化  

交换器的持久化，是通过在声明队列时将 durable 参数置为 true 实现的，不设置持久化的话，交换器的信息将会丢失。   

- 队列持久化  

队列的持久化，是通过在声明队列时将 durable 参数置为 true 实现的，队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。   

- 消息的持久化   

消息的持久化，在投递时指定 `delivery_mode=2`（1是非持久化），消息的持久化，需要配合队列的持久，只设置消息的持久化，重启之后队列消失，继而消息也会丢失。所以如果只设置消息持久化而不设置队列的持久化意义不大。   
    
对于持久化，如果所有的消息都设置持久化，会影响写入的性能，所以可以选择对可靠性要求比较高的消息进行持久化处理。     

不过消息持久化并不能百分之百避免消息的丢失    

比如数据在落盘的过程中宕机了，消息还没及时同步到内存中，这也是会丢数据的，这种问题可以通过引入镜像队列来解决。   

镜像队列的作用：引入镜像队列，可已将队列镜像到集群中的其他 Broker 节点之上，如果集群中的一个节点失效了，队列能够自动切换到镜像中的另一个节点上来保证服务的可用性。(更细节的这里不展开讨论了)    

##### Kafka 中的防丢失措施

操作系统本身有一层缓存，叫做 Page Cache，当往磁盘文件写入的时候，系统会先将数据流写入缓存中。   

Kafka 收到消息后也会先存储在也缓存中(Page Cache)中，之后由操作系统根据自己的策略进行刷盘或者通过 fsync 命令强制刷盘。如果系统挂掉，在 PageCache 中的数据就会丢失。也就是对应的 Broker 中的数据就会丢失了。     

处理思路  

1、控制竞选分区 leader 的 Broker。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。   

2、控制消息能够被写入到多个副本中才能提交，这样避免上面的问题1。   

##### rocketmq 中的防丢失措施

1、将刷盘方式改成同步刷盘；   

2、对于多个节点的 Broker，需要将 Broker 集群配置成：至少将消息发送到 2 个以上的节点，再给客户端回复发送确认响应。这样当某个 Broker 宕机时，其他的 Broker 可以替代宕机的 Broker，也不会发生消息丢失。   

### 消息重复发送

### 处理消息的挤压

### 参考  

【消息队列高手课】https://time.geekbang.org/column/intro/100032301     
【消息队列设计精要】https://tech.meituan.com/2016/07/01/mq-design.html    
【RabbitMQ实战指南】https://book.douban.com/subject/27591386/      
【分布式事务最经典的七种解决方案】https://segmentfault.com/a/1190000040321750     
【分布式事务的实现原理】https://draveness.me/distributed-transaction-principle/   
【理解分布式事务】https://juejin.cn/post/6844903734753886216     
【设计(design)】https://github.com/apache/rocketmq/blob/master/docs/cn/design.md  
【Kafka 是如何实现事务的？】https://zhuanlan.zhihu.com/p/163683403    
【MQ - RabbitMQ Cluster】https://www.cnblogs.com/Neeo/articles/13915836.html    
【如何避免消息丢失?】https://www.lixueduan.com/post/kafka/09-avoid-msg-lost/    