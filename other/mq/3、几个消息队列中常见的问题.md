<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [消息队列常见问题处理](#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86)
  - [分布式事务](#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1)
    - [什么是分布式事务](#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1)
    - [常见的分布式事务解决方案](#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
    - [本地消息表 - 最终一致性](#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8---%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7)
  - [消息防丢失](#%E6%B6%88%E6%81%AF%E9%98%B2%E4%B8%A2%E5%A4%B1)
  - [消息重复发送](#%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81)
  - [处理消息的挤压](#%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%9A%84%E6%8C%A4%E5%8E%8B)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 消息队列常见问题处理

### 分布式事务

#### 什么是分布式事务

我们的服务器从单机发展到拥有多台机器的分布式系统，各个系统之前需要借助于网络进行通信，原有单机中相对可靠的方法调用以及进程间通信方式已经没有办法使用，同时网络环境也是不稳定的，造成了我们多个机器之间的数据同步问题，这就是典型的分布式事务问题。  

在分布式事务中事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。分布式事务就是要保证不同节点之间的数据一致性。    

#### 常见的分布式事务解决方案

1、2PC(二阶段提交)方案 - 强一致性  

2、3PC(三阶段提交)方案  

3、TCC （Try-Confirm-Cancel）事务 - 最终一致性   

4、Saga事务 - 最终一致性

5、本地消息表 - 最终一致性  

6、MQ事务 - 最终一致性

这里重点关注下使用消息队列实现分布式的一致性，上面几种的分布式设计方案的具体细节可参见文章最后的引用链接      

#### 本地消息表 - 最终一致性   

消息的生产方，除了维护自己的业务逻辑之外，同时需要维护一个消息表。这个消息表里面记录的就是需要同步到别的服务的信息，当然这个消息表，每个消息都有一个状态值，来标识这个消息有没有被成功处理。   

发送放的业务逻辑以及消息表中数据的插入将在一个事务中完成，这样避免了`业务处理成功 + 事务消息发送失败`，或`业务处理失败 + 事务消息发送成功`，这个问题。    

举个栗子：   

我们假定目前有两个服务，一个用户服务，一个订单服务。用户服务也就是我们的消息发起方。用户服务中先扣除用户的钱，然后订单服务中进行向应订单的生成。   

**1、消息的生产方也就是用户服务，完成了自己的逻辑(扣除用户对应商品的钱)然后把这个消息通过 mq 发送到需要进行数据同步的其他服务中，也就是我们栗子中的订单服务。**

**2、其他服务(订单服务)会监听这个队列；**  

1、如果收到这个消息，并且数据同步执行成功了，当然这也是一个本地事务，就通过 mq 回复消息的生产方(用户服务)消息已经处理了，然后生产方就能标识本次事务已经结束。如果是一个业务上的错误,就回复消息的生产方，需要进行数据回滚了。   

2、很久没收到这个消息，这种情况是不会发生的，消息的发送方会有一个定时的任务，会定时重试发送消息表中还没有处理的消息；

**3、消息的生产方(用户服务)如果收到消息回执；**  

1、成功的话就修改本次消息已经处理完，也就是本次分布式事务的同步已经完成；   

2、如果消息的结果是执行失败，同时在本地回滚本次事务，表示消息已经处理完成；   

3、如果消息丢失，也就是回执消息没有收到，这种情况也不太会发生，消息的发送方(用户服务)会有一个定时的任务，定时重试发送消息表中还没有处理的消息，下游的服务需要做幂等，可能会收到多次重复的消息，如果一个回执丢失了，后面持续收到发送方的 mq 消息。     

- 2、MQ事务 - 最终一致性   








### 消息防丢失

### 消息重复发送

### 处理消息的挤压

### 参考  

【消息队列高手课】https://time.geekbang.org/column/intro/100032301     
【消息队列设计精要】https://tech.meituan.com/2016/07/01/mq-design.html    
【RabbitMQ实战指南】https://book.douban.com/subject/27591386/      
【分布式事务最经典的七种解决方案】https://segmentfault.com/a/1190000040321750     
【分布式事务的实现原理】https://draveness.me/distributed-transaction-principle/   
【理解分布式事务】https://juejin.cn/post/6844903734753886216     