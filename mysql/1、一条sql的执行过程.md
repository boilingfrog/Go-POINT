<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [一条 SQL 的执行过程](#%E4%B8%80%E6%9D%A1-sql-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [查询](#%E6%9F%A5%E8%AF%A2)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 一条 SQL 的执行过程  

### 前言

在开始学习 MySQL 中知识点的时候，首先来看下 SQL 在 MySQL 中的执行过程。    

### 查询

查询语句是我们经常用到的，那么一个简单的查询 sql，在 MySQL 中的执行过程是怎么样的呢？    

```
SELECT * FROM user WHERE id =1
```

栗如上面的这个简单的查询语句，来看下具体的查询逻辑。    

<img src="/img/mysql/mysql-query.png"  alt="mysql" />    

MySQL 主要分为 Server 层和存储引擎层两部分。  

Server 层包括连接器、查询缓存。分析器、执行器等。MySQL 中大多数的核心功能，所有的内置函数，所有跨存储引擎的功能都在这一层实现。栗如：存储过程，触发器，视图等。。。   

存储引擎层负责数据的存储和提取。其架构是插件式的，支持 `InnoDB、MyISAM、Memory` 等多个存储引擎。`MySQL 5.5.5` InnoDB 成为了默认的存储引擎。   

**连接器**   

大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。  

这里主要的工作就是管理和客户端的连接，同时进行连接的权限认证。     

- 如果用户名密码不对，就会有一个 "Access denied for user" 的错误提示。  

- 如果用户名密码认证通过，连接器中会在权限表中查询改账号拥有的权限，之后所有的权限判断逻辑，都依赖于此时读到的权限。    

这就意味着，一旦一个用户建立连接后，即使对这个账号进行了权限的修改，对已经建立的连接也不会产生影响。只有新建连接，才能使用新的权限。   

客户端如何太长时间没有动静，连接器会断开连接，这个时间由参数 wait_timeout 控制默认 8 小时。   

数据库的连接分成两种类型短连接和短链接：  

长连接：长连接在连接成功之后，后面客户端的请求，可以复用这个连接；   

短连接：短连接每次执行完几次查询就断开连接，每次客户端的请求都会新建一个。   

因为建立连接的过程是很复杂，并且是有一定开销的，应该尽量减少连接的建立，长连接更加推荐使用。  

为了避免线程被频繁的创建和销毁，影响性能，`MySQL5.5` 版本引入了线程池，会缓存创建的线程，不需要为每一个新建的连接，创建或销毁线程。可以使用线程池中少量的线程服务大量的连接。    

**查询缓存**

MySQL 查询缓存，为了提高相同 Query 语句的响应速度，会缓存特定 Query 的整个结果集信息，当后面有相同的查询语句，直接查询缓存，返回查询的结果。当命中的时候不需要执行后面复杂的操作，就可以直接返回结果，查询效率是很高的。           

不过当一个表有更新的时候，和这个表有关的查询缓存都会被删除，造成查询缓存的失效。所以更新较频繁的数据库不建议使用查询缓存，命中率会非常的低。所以，长时间不更新的静态表，这种适合使用查询缓存。     

在 `MySQL 5.6` 开始，就已经默认禁用查询缓存了。在 `MySQL 8.0`，就已经删除查询缓存功能了。  

**执行与优化**  

1、当 SQL 需要执行时候，首先分析器会做一个此法分析和语法分析，一条 SQL 语句由字符串和空格组成，MySQL 需要识别出里面的字符串分别是什么，代表什么。     

2、优化执行：利用数据库的统计信息决定 SQL 语句的最佳执行方式，选择合适的索引，找出最优的查询方案；   

3、执行器：会根据优化后的 SQL，向存储引擎发起查询操作，并且返回查询的结果。     

总体来说就是   

MySQL 会解析查询，并创建内部的数据结构(解析树)，然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引。  

### 参考

【高性能MySQL(第3版)】https://book.douban.com/subject/23008813/    
【MySQL 实战 45 讲】https://time.geekbang.org/column/100020801  