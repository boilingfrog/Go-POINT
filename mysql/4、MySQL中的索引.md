<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [MySQL 中的索引](#mysql-%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [索引的实现](#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0)
    - [哈希索引](#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95)
    - [全文索引](#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95)
    - [B+ 树索引](#b-%E6%A0%91%E7%B4%A2%E5%BC%95)
  - [索引的分类](#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## MySQL 中的索引

### 前言  

上篇文章聊完了 MySQL 中的锁，这里接着来看下 MySQL 中的索引。  

一般当我们数据库中的某些查询比较慢的时候，正常情况下，一顿分析下来，大多数我们会考虑对这个查询加个索引，那么索引是如何工作的呢？为什么索引能加快查询的速度，下面来具体的分析下。   

在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。  

索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。  

### 索引的实现   

InnoDB 支持三种索引模型：  

1、哈希索引；  

2、全文索引；  

3、B+ 树索引。   

#### 哈希索引

哈希表也称为散列，是一种以键-值 (key-value) 存储数据的结构。输入查询的 key,就能找到对应的 value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。   

当然会存在哈希冲突，对个 key 在经过哈希算法处理后可能出现在哈希表中的同一个槽位，当出现哈希冲突的时候，可以使用链表来解决。这样发生冲突的数据都放入到链表中。在进行数据查询的时候，首先找到哈希表中的槽位，然后在链表中依次遍历找到对应的值。    

<img src="/img/mysql/mysql-hash.png"  alt="mysql" />  

哈希表的这种结构适合于等值查询的场景，在最优场景的下的时间复杂度能达到 `O(1)`。    

哈希索引的缺点  

1、因为是哈希表存储的是 Hash 运算之后的 Hash值，所以它只能用于等值的查询，范围查询在哈希索引中不支持；  

2、无法利用索引排序，索引中存储的只是 Hash 计算之后的 Hash 值，对于排序，索引本身无法支持；  

3、组合索引不能利用部分索引，也就是不支持最左匹配原则，对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用；  

4、哈希索引需要进行回表查询，因为哈希索引存储的都是哈希值和行指针，所以不能避免使用索引来避免读取行。   

#### 全文索引

全文索引就是将存储于数据库中的整本书或整篇文章中的任意内容信息找出来的技术，可以根据需求获取全文中的有关文章，节，段，句，词等信息，也能进行统计和分析。  

InnoDB 最早是不支持存储全文索引的，想要使用全文索引就要选用 MySIAM 存储引擎,从版本 `1.2.x` 开始才增加了全文索引支持。   

全文索引一般使用倒排索引(inverted index)实现，倒排索引和 B+ 树索引一样，也是一种索引结构。  

倒排索引在辅助表 (auxiliary table) 中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这样当全文索引，匹配到对应的单词就能知道对应的文档位置了。    

倒排索引是区别于正排索引的概念：  

正排索引：是以文档对象的唯一 ID 作为索引，以文档内容作为记录的结构。  

倒排索引：`Inverted index`，指的是将文档内容中的单词作为索引，将包含该词的文档 ID 作为记录的结构。    

倒排索引中文档和单词的关联关系，通常使用关联数据实现，主要有两种实现方式：  

1、`inverted file index`: 会记录单词和单词所在的文档 ID 之间的映射；  

2、`full inverted index`: 这种方式记录的更详细，除了会记录单词和单词所在的文档 ID 之间的映射，还会记录单词所在文档中的具体位置。   

下面来举个栗子  

<img src="/img/mysql/mysql-full-text-search-demo-1.jpg"  alt="mysql" />     

DocumentId 表示全文索引中文件的 id, Text 表示存储的内容。这些存储的文档就是全文索引需要查询的对象。     

`inverted file index`  

<img src="/img/mysql/mysql-full-text-search-demo-2.jpg"  alt="mysql" />    

可以看到关联中，记录了单词和 DocumentId 的映射，这样通过对应的单词就能找到，单词所在的文档，不用一个个遍历文档了。   

`full inverted index`

<img src="/img/mysql/mysql-full-text-search-demo-3.jpg"  alt="mysql" />  

这种方式和上面的 `inverted file index` 一样也会记录单词和文档的映射，只不过记录的更详细了，还记录了单词在文档中的具体位置。   

相比于 `inverted file index` 优点就是定位更精确，缺点也是很明显，需要用更多的空间。    

InnoDB 存储引擎支持全文索引采用 `full inverted index` 的方式，将`(DocumentId，Position)` 视为一个 `ilist`。  

因此在全文检索的表中，一共有两列，一列是 word 字段，另一个是 `ilist`，并且在 word 字段上设有索引。    

记录单词和 DocumentId 的映射关系的表称为 `Auxiliary Table`（辅助表）。   

辅助表是存在与磁盘上的持久化的表，由于磁盘 `I/O` 比较慢，因此提供 `FTS Index Cache`（全文检索索引缓存）来提高性能。`FTS Index Cache` 是一个红黑树结构，根据`（word, list）`排序，在有数据插入时，索引先更新到缓存中，而后 InnoDB 存储引擎会批量进行更新到辅助表中。    

#### B+ 树索引

B+ 树就是传统意义上的索引，这是目前关系型数据库中查找最为常用和最为有效的索引。B+ 树构造的索引类似于二叉树，根据键值快速 (Key Value) 快速找到数据。   

有一点需要注意的是，B+ 树索引并不能找到给定键值具体的行。B+ 树索引能找到的只是被查找数据行所在的页。然后把页读入到内存中，再在内存中查找，找到查询的目标数据。  

B+ 树是 B 树的变种，这里需要了解下 B 树。   

**为什么要引入 B 树或者 B+ 树呢？**   

红黑树等其它的数据结构也可以用来实现索引，为什么要使用 B 树或者 B+ 树，简单点讲就是为了减少磁盘的 I/O。     

一般来说，索引本身的数据量很大，全部放入到内存中是不太现实的，因此索引往往以索引文件的形式存储在磁盘中，磁盘 I/O 的消耗相比于内存中的读取还是大了很多的，在机械硬盘时代，从磁盘随机读一个数据块需要`10 ms`左右的寻址时间。     

为了让一个查询尽量少地读磁盘，就需要减少树的高度，就不能使用二叉树，而是使用 N 叉树了，这样就能在遍历较少节点的情况下也就是较少 I/O 查询的情况下找到目标值。    

比如一个二叉树，访问底部数据需要进行4次 I/O 操作。  

<img src="/img/mysql/mysq-binary-tree-demo.png"  alt="mysql" />     

如果使用4叉树，那么树的层架就会变矮，这时候只需要进行3次 I/O 操作。   

<img src="/img/mysql/mysql-quadtree-demo.png"  alt="mysql" />       

数据量越来越大，N 叉树的效果更明显，在有相同数据的情况下，对于二叉树，能够大大缩小树的高度。    

所以 B 树和 B+ 树就被慢慢演变而来了。     

自平衡二叉树虽然能保持查询操作的时间复杂度在 `O(logn)`，但是因为它本质上是一个二叉树，每个节点只能有 2 个子节点，那么当节点个数越多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。  

为了解决降低树的高度的问题，后面就出来了 B 树，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 `(M>2)`，从而降低树的高度。    

为什么 MySQL 用的是 B+ 树 而不是 B 树呢，这里来看下区别？   

`B-tree` 和 `B+` 树最重要的区别是 `B+` 树只有叶子节点存储数据，其他节点用于索引，而 `B-tree` 对于每个索引节点都有 `Data` 字段。   

<img src="/img/mysql/mysql-btree"  alt="mysql" />     

B 树简单的讲就是一种多叉平衡查找树，它类似于普通的平衡二叉树。不同的是 B-tree 允许每个节点有更多的子节点，这样就能大大减少树的高度。   

<img src="/img/mysql/mysql-b+tree"  alt="mysql" />         

B-Tree 结构图中可以看到每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。   

B+ 树相比与 B 树：   

1、非叶子节点只存储索引信息；  

2、所有叶子节点都有一个链指针，所以B+ 树可以进行范围查询；  

3、数据都放在叶子节点中。   

### 索引的分类  

主键索引  



### 参考

【高性能MySQL(第3版)】https://book.douban.com/subject/23008813/    
【MySQL 实战 45 讲】https://time.geekbang.org/column/100020801  
【MySQL技术内幕】https://book.douban.com/subject/24708143/    
【MySQL学习笔记】https://github.com/boilingfrog/Go-POINT/tree/master/mysql    
【what-is-the-difference-between-mysql-innodb-b-tree-index-and-hash-index】https://medium.com/@mena.meseha/what-is-the-difference-between-mysql-innodb-b-tree-index-and-hash-index-ed8f2ce66d69  



