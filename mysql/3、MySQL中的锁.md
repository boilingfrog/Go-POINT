<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [MySQL 中的锁理解](#mysql-%E4%B8%AD%E7%9A%84%E9%94%81%E7%90%86%E8%A7%A3)
  - [锁的类型](#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B)
  - [全局锁](#%E5%85%A8%E5%B1%80%E9%94%81)
    - [缺点](#%E7%BC%BA%E7%82%B9)
    - [适用范围](#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4)
  - [表级锁](#%E8%A1%A8%E7%BA%A7%E9%94%81)
    - [表锁](#%E8%A1%A8%E9%94%81)
    - [元数据锁](#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81)
    - [意向锁](#%E6%84%8F%E5%90%91%E9%94%81)
    - [自增锁](#%E8%87%AA%E5%A2%9E%E9%94%81)
  - [行锁](#%E8%A1%8C%E9%94%81)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## MySQL 中的锁理解

### 锁的类型

MySQL 找那个根据加锁的范围，大致可以分成全局锁，表级锁和行级锁。   

### 全局锁

全局锁，就是对整个数据库加锁。      

加锁

```
flush tables with read lock
```

解锁

```
unlock tables
```

全局锁会让整个库处于只读状态，之后所有的更新操作都会被阻塞：   

- 数据更新语句（数据的增删改）；    

- 数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。  

#### 缺点

如果对主库加锁，那么执行期间就不能执行更新，业务基本上就停摆了；   

如果对从库加锁，那么执行期间，从库就不能执行主库同步过来的 binlog，会导致主从延迟。         

#### 适用范围

全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。

不过为什么要在备份的时候加锁，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。  

官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 `–single-transaction` 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。   

对于 MyISAM 这种不支持事务的引擎，mysqldump 工具就不能用了，所以 全局锁 虽然缺点很多，但是还是有存在的必要。   

### 表级锁

MySQL 中的表级别的锁包括:表锁，元数据锁(meta data lock，MDL)。   

比如 InnoDB 中的意向锁和自增锁（AUTO-INC Locks）也都是表级别的锁。  

下面来一一分析下  

#### 表锁    

表锁，就是会锁定整张表，它是 MySQL 中最基本的锁策略，并不依赖于存储引擎，被大部分的 MySQL 引擎支持，MyISAM 和 InnoDB 都支持表级锁，由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。   

表级别的锁，和全局锁一样可以使用 `unlock tables` 主动释放锁，也可以在客户端断开的时候自动释放锁。    

加锁  

```
// 表级别的共享锁，也就是读锁
lock tables t1 read

// 表级别的排它锁，也就是写锁   
lock tables t1 write
```

释放锁   

```
unlock tables
```

表锁除了会限制其它线程的读写，还会限制当前线程接下来的操作。   

如果一个线程加了表级别的读锁，其他线程对该表的写操作，都会被阻塞，同时当前线程接下来对该表的写入操作也不能执行，会报错当前表有一个读锁，直到表锁的读锁被释放。        

#### 元数据锁

MDL（metadata lock) 元数据也是表级别的锁。  

MDL 锁主要使用来维护表元数据的数据一致性，MDL 不需要显式使用，在访问一个表的时候会被自动加上，避免在进行读取或者写入的时候，其它线程对数据表做出修改，造成写入或者读取的结果异常。   

因此，在 `MySQL 5.5` 版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。     

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查；     

- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。      

给一个表加字段会可能会导致整个库崩掉，为什么呢？   

<img src="/img/mysql/mysql-mdl-lock-demo.png"  alt="mysql" />    

来分析下上面的栗子  

1、`session A` 首先启动事务，使用了一个查询，因为是查询，所以对 user 表会加一个 MDL 读锁；   

2、`session B` 因为也是查询，所以也是加 MDL 读锁，读读不互斥，所以改该查询就正常进行了；   

3、`session C` 是一个对表添加字段的操作，会加 MDL 写锁，因为 `session A` 中的读锁还没有提交，读写互斥，该线程就会被阻塞了；    

4、`session D` 也是一个读锁，不过因为 `session C` 加了一个写锁，这时候 `session D` 的读锁会被 `session C` 阻塞，因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。这样后面申请 MDL 读锁都会被阻塞，因为对表的增删改查操作都需要先申请MDL读锁，基本上这个表就完全不能读写了。  

如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。     

MDL 锁会需要等到事务提交的时候才会被释放，这样在给表加字段的时候遇到一个长事务，就可能会导致数据表崩掉。     

如何安全的对数据表添加字段呢？     

设置 `alter table` 语句中的等待时间，如果在指定时间没有拿到 MDL 写锁，直接退出，不至于长时间阻塞后面的业务操作。失败，就后面多尝试几次。    

#### 意向锁

#### 自增锁

### 行锁

### 参考

【高性能MySQL(第3版)】https://book.douban.com/subject/23008813/    
【MySQL 实战 45 讲】https://time.geekbang.org/column/100020801  
【MySQL技术内幕】https://book.douban.com/subject/24708143/    
【MySQL学习笔记】https://github.com/boilingfrog/Go-POINT/tree/master/mysql    



