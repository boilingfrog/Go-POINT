## channel

### 前言

`channel`作为go中并发的一神器，深入研究下吧。  

### 设计的原理

在早期，CPU都是以单核的形式顺序执⾏机器指令。Go语⾔的祖先C语⾔正是这种顺序编程语⾔的代 表。顺序编程语⾔中的顺序是指：所有的指
令都是以串⾏的⽅式执⾏，在相同的时刻有且仅有⼀个 CPU在顺序执⾏程序的指令。

随着处理器技术的发展，单核时代以提升处理器频率来提⾼运⾏效率的⽅式遇到了瓶颈，⽬前各种主 流的CPU频率基本被锁定在了3GHZ附近。单核CPU的
发展的停滞，给多核CPU的发展带来了机遇。 相应地，编程语⾔也开始逐步向并⾏化的⽅向发展。Go语⾔正是在多核和⽹络化的时代背景下诞⽣的 原⽣
⽀持并发的编程语⾔。  

常⻅的并⾏编程有多种模型，主要有多线程、消息传递等。从理论上来看，多线程和基于消息的并发 编程是等价的。由于多线程并发模型可以⾃然对应
到多核的处理器，主流的操作系统因此也都提供了系统级的多线程⽀持，同时从概念上讲多线程似乎也更直观，因此多线程编程模型逐步被吸纳到主流
的编程语⾔特性或语⾔扩展库中。⽽主流编程语⾔对基于消息的并发编程模型⽀持则相⽐较少，Erlang语⾔是⽀持基于消息传递并发编程模型的代表者，
它的并发体之间不共享内存。Go语⾔是基于 消息并发模型的集⼤成者，它将基于CSP模型的并发编程内置到了语⾔中，通过⼀个go关键字就可以 轻易地
启动⼀个Goroutine，与Erlang不同的是Go语⾔的Goroutine之间是共享内存的。  

#### 共享内存

多线程共享内存。其实就是Java或者C++等语言中的多线程开发。单个的goutine代码是顺序执行，而并发编程时，创建多个goroutine，但我们并
不能确定不同的goroutine之间的执行顺序，多个goroutine之间大部分情况是代码交叉执行，在执行过程中，可能会修改或读取共享内存变量，这样
就会产生数据竞争,但是我们可以用锁去消除数据的竞争。  

当然这种在go中是不推荐的  

#### csp

Go语⾔最吸引⼈的地⽅是它内建的并发⽀持。Go语⾔并发体系的理论是C.A.R	Hoare在1978年提出的 CSP（Communicating	Sequential	Process，
通讯顺序进程）。CSP有着精确的数学模型，并实际应 ⽤在了Hoare参与设计的T9000通⽤计算机上。从NewSqueak、Alef、Limbo到现在的Go语⾔，对于
对 CSP有着20多年实战经验的Rob	Pike来说，他更关注的是将CSP应⽤在通⽤编程语⾔上产⽣的潜⼒。 作为Go并发编程核⼼的CSP理论的核⼼概念只有
⼀个：同步通信。  

⾸先要明确⼀个概念：并发不是并⾏。并发更关注的是程序的设计层⾯，并发的程序完全是可以顺序 执⾏的，只有在真正的多核CPU上才可能真正地同时运⾏。
并⾏更关注的是程序的运⾏层⾯，并⾏⼀ 般是简单的⼤量重复，例如GPU中对图像处理都会有⼤量的并⾏运算。为更好的编写并发程序，从设 计之初Go语⾔
就注重如何在编程语⾔层级上设计⼀个简洁安全⾼效的抽象模型，让程序员专注于分解 问题和组合⽅案，⽽且不⽤被线程管理和信号互斥这些繁琐的操作分
散精⼒。  

在并发编程中，对共享资源的正确访问需要精确的控制，在⽬前的绝⼤多数语⾔中，都是通过加锁等线程同步⽅案来解决这⼀困难问题，⽽Go语⾔却另辟蹊
径，它将共享的值通过Channel传递(实际上多 个独⽴执⾏的线程很少主动共享资源)。在任意给定的时刻，最好只有⼀个Goroutine能够拥有该资源。数
据竞争从设计层⾯上就被杜绝了。为了提倡这种思考⽅式，Go语⾔将其并发编程哲学化为⼀句⼝号：

> Do	not	communicate	by	sharing	memory;	instead,	share	memory	by	communicating.

不要通过共享内存来通信，⽽应通过通信来共享内存。  
这是更⾼层次的并发编程哲学(通过管道来传值是Go语⾔推荐的做法)。虽然像引⽤计数这类简单的并 发问题通过原⼦操作或互斥锁就能很好地实现，但是通
过Channel来控制访问能够让你写出更简洁正确的程序。  

### channel

Golang中使用 CSP中 channel 这个概念。channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式的，一个实体通
过将消息发送到channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 channel 是同步的一
个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的。  

#### channel的定义

channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。go中内置的类型，初始化的时候，我们需要初始化
channel的长度。  

指定了长度代表有缓冲
```go
ch := make(chan int, 1)
```

未指定就是无缓冲
```go
ch := make(chan int)
```

有缓冲和无缓冲的差别是什么呢？  











### 参考

【Go的CSP并发模型】https://www.jianshu.com/p/a3c9a05466e1  
【goroutine, channel 和 CSP】http://www.moye.me/2017/05/05/go-concurrency-patterns/  
【通过同步和加锁解决多线程的线程安全问题】https://blog.ailemon.me/2019/05/15/solving-multithreaded-thread-safety-problems-by-synchronization-and-locking/  