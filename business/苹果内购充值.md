<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [苹果内购](#%E8%8B%B9%E6%9E%9C%E5%86%85%E8%B4%AD)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [苹果内购](#%E8%8B%B9%E6%9E%9C%E5%86%85%E8%B4%AD-1)
  - [苹果支付的难点](#%E8%8B%B9%E6%9E%9C%E6%94%AF%E4%BB%98%E7%9A%84%E9%9A%BE%E7%82%B9)
  - [方案设计](#%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1)
    - [1、商品设计](#1%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1)
    - [2、用户和回执的绑定](#2%E7%94%A8%E6%88%B7%E5%92%8C%E5%9B%9E%E6%89%A7%E7%9A%84%E7%BB%91%E5%AE%9A)
    - [3、回调的重试](#3%E5%9B%9E%E8%B0%83%E7%9A%84%E9%87%8D%E8%AF%95)
  - [充值冲遇到的问题点](#%E5%85%85%E5%80%BC%E5%86%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E7%82%B9)
    - [1、丢单](#1%E4%B8%A2%E5%8D%95)
    - [2、充值成功，下发的物品不对](#2%E5%85%85%E5%80%BC%E6%88%90%E5%8A%9F%E4%B8%8B%E5%8F%91%E7%9A%84%E7%89%A9%E5%93%81%E4%B8%8D%E5%AF%B9)
    - [3、处理退款](#3%E5%A4%84%E7%90%86%E9%80%80%E6%AC%BE)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 苹果内购

### 前言

接触公司的充值业务很久了,在处理苹果充值的时候也踩了很多的坑，这里就花时间来总结下。

### 苹果内购

IAP 全称：`In-App Purchase`，是指苹果 `App Store` 的应用内购买，是苹果为 App 内购买虚拟商品或服务提供的一套交易系统。

为什么这里着重来介绍 IAP 呢，因为 IAP 和微信支付和支付宝支付的实现逻辑不太一样，因为 IAP 支付依赖 IOS 客户端调用异步支付回调接口，进行用户和订单的绑定，会有丢单的情况产生，这里
假定大家对苹果支付有一定了解了，重点主要是来聊下苹果支付的技术实现方案。

聊下，目前 IAP 中充值我们遇到的问题点

1、丢单；

2、订单充值到错误的账号；

3、在苹果设置中直接点击充值，导致不到账。

### 苹果支付的难点  

关于苹果充值的难点，这边总结下来就是下面两点：   

1、如何处理订单回执和用户账号的绑定关系；   

2、APP 中复杂的网络环境，如何保证订单能够成功回调；

### 方案设计

下面来介绍下苹果支付中需要特别关注的点。  

#### 1、商品设计

苹果对应的充值商品 id 需要进行申请，命名规则没有强制性的要求，需要根据自己的商品类型来进行映射。通常的做法，服务端会定义自己系统的内部的商品，服务端会提供一个提供一个商品列表的接口，会把自己系统内部的商品信息，映射到苹果系统中的商品id。  

如何合理的设计苹果 iap 的商品ID呢？一般有两种做法？  

1、每个系统内部的商品都对应一个苹果 iap 的商品id;  

这种就是需要申请的商品id比较多，同时如果商品信息发生更改，就需要重新申请，当然，如果自己系统内部的商品，比较单一，并且基本上能够保持不变，那这种方式可以商品设计的选择之一。  

2、每种类型的商品，一个价格对应一个苹果 iap 的商品id；  

苹果的 iap 的商品id和价格做绑定了，如果商品信息有变化，只要价格不变，就不用重新申请对应的 iap 商品id 了。    

具体使用哪种可以根据自己系统中的商品特点来进行选择。   

#### 2、用户和回执的绑定

苹果支付中，苹果回调中的是没有第三方订单信息的，所以，苹果订单回执信息和用户的绑定需要在 APP 中完成。  

苹果充值成功，给到 IOS 客户端充值的回调信息，然后客户端需要把当前的回执信息和当前的用户做好绑定，上报数据到自己的服务端，进行订单校验和充值道具的下发。     

处理处理的时候，每一笔订单都会生成唯一的订单号。用户和回执信息的绑定，也就是，订单号和用户回执信息的绑定，因为订单对应数据，里面会关联用户信息。  

这样用户和回执的绑定也就回归到用户订单和苹果回执的绑定，那么订单号在何时生成，如何和苹果回执做绑定呢？有两种方案，下面来一一探讨下。   

1、生成订单 -> 发起 iap 充值 -> 客户端 绑定订单id和 iap 充值的回执信息，向服务端发起回调 -> 服务端接收到回调信息，校验订单回执，给用户增加道具；  

2、发起 iap 充值 -> 接收到回调信息 -> 客户端将商品信息，用户信息，iap 的回执信息，一起回调给服务端 -> 服务端接收到回调信息，校验回执信息，生成对应的订单，生成给用户增加道具；   

这两种最主要的差别就是订单的生成时机不同，第一中订单号对客户端是可见的，第二种订单号对客户端是不可见的。    

**1、订单提前生成**

<img src="/img/business/apple-iap-order-before.png"  alt="iap" />    

订单提前生成，比较符合我们处理的订单的逻辑，如果自己的充值系统中也同时集成了微信和支付宝的支付，那么选用这种方式，订单的处理就相对统一。    

缺点：  

1、每次点击充值就会有一个订单的生成，即使用户后面没有实际的充值，会有无效订单数据的产生；   

2、因为订单号和苹果回执信息的绑定是需要在客户端中进行绑定操作的，那么这个就会存在绑定错乱的情况，用户可能点击充值了多个商品，这时候处理绑定的时候， A 商品的订单号，绑定到了 B 商品的回执信息上了。结果就是用户订单异常。   

**2、回调的时候生成订单号**

<img src="/img/business/apple-iap-order-after.png"  alt="iap" />    

订单是后面生成的，所以可以控制只有回执信息验证通过的时候才生成订单号，避免了无用订单的生成。   

不过这两种处理方式个人感觉差别不大，设计的时候考虑下如果有其它的支付方式同时存在，如何做好兼容就行了。   

我们用的第一种，提前生成订单，因为我们系统中同时存在了，微信，支付宝和苹果充值，所以各个充值方式的兼容也是我们考虑的一个重要的点。  

不过也根据第一种方式做了细微的调整，因为苹果充值存在充值成功但是回调是失败的情况，接收到失败的订单回调，本地记录的订单号就会被清理了，这时候有成功的回调过来，本地就没有对应的订单号了，同时对于订阅商品，下一个扣款日重新发我续订，app 接收到回调通知，本地也是没有存储对应的订单号。没有订单号，也就意味着苹果的充值回执信息，和用户关联不上了。这种情况，我们的处理方式就是，app 接收到成功的回调，本地没有订单号，就重新调用服务端接口重新生成一个。保证用户和苹果的回执信息一定能关联上。       

<img src="/img/business/apple-iap-order-create.png"  alt="iap" />    

#### 3、回调的重试

因为苹果订单的绑定依赖于客户端，当网络环境不好，接收到回调信息，之后向自己的服务端进行回执信息的验证，出现接口请求不通的情况，这时候就需要执行回调回执的重试。   

当然重试分成两部分  

1、客户端回调回执信息的重试；  

2、服务端验证回执信息的重试。   

一般服务端在设计充值的时候，都会使用到分布式事务，消息队列等来保证事务的最终一致性。同时对于一些第三方的请求，也会有对应的重试机制：  

1、数据标记法：接收到请求，先落数据库，如果验证成功将数据标记成功，如果一直没有验证处理成功，就定时从数据库将此数据取出来，继续重试验证的逻辑；   

2、消息队列的重试机制：一般消息队列都有对应的重试机制，消息验证成功，就将消息从队列中移除，否则重新丢到队列中，借助队列的重试机制，知道本消息处理成功。     

客户端部分的重试步骤：  

1、接收到苹果的回调，拼接订单和用户信息，向自己的服务端发起回调；  

2、如果自己服务端的回调接口，返回成功，在一定时间内定时查询该订单的状态，如果订单返回成功，更新用户的账户信息；  

3、如果回调自己的服务端失败，这时候就需要进行重试操作，1分钟内重试5次，直到该回调接口返回成功的状态；  

4、如果1分钟内重试了5次还是失败，记录该回执信息，用户打开app，或者切换到充值页面的时候继续重试。   

因为对于回调的处理，服务端只要接收到请求，就会记录该回调信息，然后接口返回成功，所以只要客户端的网络正常，这种失败的情况是不会出现的，多次的重试操作一定能规避这种情况。  

### 充值冲遇到的问题点

#### 1、丢单

丢单是苹果充值经常遇到的问题，因为是 app 接收到的苹果的服务回调，相比于服务端的 `sever to server` 的通知，受限于客户端的当时的网络环境，app 的打开状况，稳定性是偏差的。  

如何处理呢？  

原则上就是客户端接收到苹果的回调通知，尽可能的拼接用户信息和回执信息发送给自己的服务单进行数据的验证，服务在验证数据的时候做好订单的唯一性处理，避免商品超发的情况。   

总结了可能有下面几种情况：  

1、接收到异常的回调：充值成功了，但是客户端先接收到的是一个充值失败的回调，然后草草结束掉本次订单，导致后面收到了充值成功的订单，但是订单已经结束就不处理了，最终结果就是丢单了；   

2、网络不稳定：充值成功了，客户端成功接收到了苹果的回调，但是给自己服务端回调的时候，因为网络原因导致回调失败了，结果就是用户丢单了；  

3、用户频繁切换账户：充值成功了，用户在充值过程中发生了账号的切换，因为使用的苹果账号是同一个，但是登陆 app 的账号可以是多个，切换账号的过程中，充值到其中一个账号中了，但是给到用户的体验就是当前账号没到账，就认为是丢单了；     

4、自己服务端校验票据异常：充值成功了，客户端接收到了回调，但是回调回执信息给自己服务端的时候，服务端在验证票据的时候出现了异常，导致该订单验证失败，用户的体验就是该订单丢单了；   

下面来分析下上面的几种情况：  

对于情况场景 1 和场景 2，客户端尽可能的做好重试，只要接收到苹果 iap 中的回调，就拼接信息回掉给自己的服务端，如果当前的回调接口没有返回成功的标识，就要继续重试。   

对于场景 3 ，可以在交互上优化，用户充值之后返回 app ，可以加一个充值中的 loading 页面，避免用户在这个过程中出现切换账号的操作。   

对于场景 3 ，一般服务端在设计充值这种业务的时候都会用到分布式事务，所以这种情况是能够避免的。   

#### 2、充值成功，下发的物品不对

因为充值商品，订单号和 ipa 充值回执信息的绑定是在 app 中操作的。如果用户在充值的时候有频繁点击充值的行为，那么在绑定充值回执的数据的时候，就有可能出现绑定错乱的情况。   

原来商品的 a 的回执信息，绑定时候，被绑定到了 商品 b 上面。  

这时候服务端就需要做好数据的检验，如果通过回执信息请求苹果的订单接口是能拿到，充值订单对应的 iap 商品，通过这个商品就能判断回到数据绑定的数据是否正确，如果不正确修改当前订单信息的数据即可。   

#### 3、处理退款

根据苹果的策略，用户在购买IAP后90天内，能以各种原因申请退款（扣款后购买失败、买错了、不喜欢等等）。  

用户成功申请退款了，系统中对应的道具也要清除掉，不然就是充值漏洞了，里面的商品就会被用户白嫖了。  

苹果在 `WWDC 2020` 苹果全球开发者大会，苹果宣布所有的内购项类型，当用户在应用内退款成功时，`App Store Server` 会发送实时的通知给开发者服务器告知有退款，开发者可通过处理该消息来更新用户的账户信息。   

退款流程：  

1、用户购买内购商品；  

2、用户申请退款；  

3、苹果发起退款；  

4、Apple Store Server 发送退款通知；  

5、用户收到退款成功的通知；  

6、开发者收到退款订单通知。

### 参考


